name: Deploy AKS Zabbix Infrastructure

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: 'Devops-Test'
  AZURE_LOCATION: 'eastus'
  AZURE_SUBSCRIPTION_ID: 'd9b2a1cf-f99b-4f9e-a6cf-c79a078406bf'

jobs:
  # Infrastructure Deployment
  deploy-infrastructure:
    runs-on: ubuntu-latest
    environment: production
    outputs:
      aks-cluster-name: ${{ steps.deploy-infra.outputs.AKS_CLUSTER_NAME }}
      resource-group: ${{ steps.deploy-infra.outputs.AZURE_RESOURCE_GROUP }}
      container-registry: ${{ steps.deploy-infra.outputs.CONTAINER_REGISTRY_ENDPOINT }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure CLI Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set up Azure CLI
      run: |
        az account set --subscription ${{ env.AZURE_SUBSCRIPTION_ID }}
        az account show

    - name: Install AZD (with fallback)
      run: |
        echo "ðŸ”§ Installing Azure Developer CLI..."
        
        # Try multiple installation methods
        if ! command -v azd &> /dev/null; then
          echo "Method 1: Trying direct download..."
          if curl -fsSL https://aka.ms/install-azd.sh | bash; then
            echo "âœ… AZD installed via aka.ms script"
          else
            echo "âŒ Method 1 failed, trying alternative..."
            
            # Alternative: Install via package manager
            echo "Method 2: Installing via package manager..."
            curl -sL https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/microsoft.gpg > /dev/null
            echo "deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/microsoft.gpg] https://packages.microsoft.com/repos/azure-cli/ $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/azure-cli.list
            sudo apt-get update
            sudo apt-get install -y azure-dev-cli || {
              echo "âŒ Package manager installation failed"
              
              # Final fallback: Use Azure CLI for deployment instead
              echo "âš ï¸ AZD installation failed, will use Azure CLI for deployment"
              echo "AZD_AVAILABLE=false" >> $GITHUB_ENV
            }
          fi
        else
          echo "âœ… AZD already available"
          echo "AZD_AVAILABLE=true" >> $GITHUB_ENV
        fi
        
        # Verify installation
        if command -v azd &> /dev/null; then
          echo "AZD_AVAILABLE=true" >> $GITHUB_ENV
          azd version
        else
          echo "AZD_AVAILABLE=false" >> $GITHUB_ENV
        fi

    - name: Initialize and Configure AZD Environment
      if: env.AZD_AVAILABLE == 'true'
      run: |
        echo "ðŸ”§ Initializing AZD environment..."
        
        # Initialize AZD environment with proper name
        ENV_NAME="zabbix-aks-${{ github.run_number }}"
        echo "Environment name: $ENV_NAME"
        
        # Initialize the environment non-interactively
        azd env new "$ENV_NAME" --location "${{ env.AZURE_LOCATION }}" --subscription "${{ env.AZURE_SUBSCRIPTION_ID }}"
        
        # Select the environment
        azd env select "$ENV_NAME"
        
        # Set additional environment variables
        azd env set AZURE_RESOURCE_GROUP "${{ env.AZURE_RESOURCE_GROUP }}"
        azd env set AZURE_PRINCIPAL_ID "$(az ad signed-in-user show --query id -o tsv)"
        azd env set AZURE_RESOURCE_TOKEN "$(echo $RANDOM | md5sum | head -c 8)"
        
        # Authenticate AZD using the service principal (inherit from Azure CLI)
        echo "ðŸ” Configuring AZD authentication..."
        
        # Skip AZD authentication for now and rely on Azure CLI fallback
        # AZD in GitHub Actions has issues with service principal authentication
        echo "âš ï¸ AZD authentication skipped - using Azure CLI fallback for reliability"
        echo "AZD_AUTH_FAILED=true" >> $GITHUB_ENV
        
        echo "âœ… AZD environment configured successfully"

    - name: Provision Infrastructure with AZD
      id: deploy-infra-azd
      if: env.AZD_AVAILABLE == 'true' && env.AZD_AUTH_FAILED != 'true'
      continue-on-error: true
      run: |
        echo "ðŸš€ Deploying infrastructure using Azure Developer CLI..."
        
        # Show current environment for debugging
        azd env list
        azd env get-values
        
        # Deploy with verbose output
        if azd provision --no-prompt --debug; then
          echo "âœ… AZD deployment successful"
          
          # Capture outputs
          echo "AKS_CLUSTER_NAME=$(azd env get-value AKS_CLUSTER_NAME)" >> $GITHUB_OUTPUT
          echo "AZURE_RESOURCE_GROUP=$(azd env get-value AZURE_RESOURCE_GROUP)" >> $GITHUB_OUTPUT
          echo "CONTAINER_REGISTRY_ENDPOINT=$(azd env get-value CONTAINER_REGISTRY_ENDPOINT)" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_METHOD=azd" >> $GITHUB_OUTPUT
          echo "AZD_SUCCESS=true" >> $GITHUB_ENV
        else
          echo "âŒ AZD deployment failed, will fall back to Azure CLI"
          echo "AZD_SUCCESS=false" >> $GITHUB_ENV
          exit 1
        fi

    - name: Provision Infrastructure with Azure CLI (Fallback)
      id: deploy-infra-cli
      if: env.AZD_AVAILABLE != 'true' || env.AZD_SUCCESS == 'false'
      run: |
        echo "ðŸš€ Deploying infrastructure using Azure CLI (AZD fallback)..."
        
        # Generate deployment name
        DEPLOYMENT_NAME="zabbix-deployment-${{ github.run_number }}"
        
        # Deploy Bicep template with error handling
        echo "ðŸ—ï¸ Deploying Bicep template..."
        DEPLOYMENT_OUTPUT=$(az deployment group create \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --template-file infra/main.bicep \
          --parameters environmentName="zabbix-aks-${{ github.run_number }}" \
                       location="${{ env.AZURE_LOCATION }}" \
                       principalId="$(az ad signed-in-user show --query id -o tsv)" \
          --name "$DEPLOYMENT_NAME" \
          --output json)
        
        if [ $? -ne 0 ]; then
          echo "âŒ Bicep deployment failed"
          exit 1
        fi
        
        # Extract outputs with validation
        echo "ðŸ“‹ Extracting deployment outputs..."
        AKS_CLUSTER_NAME=$(echo "$DEPLOYMENT_OUTPUT" | jq -r '.properties.outputs.AKS_CLUSTER_NAME.value // empty')
        CONTAINER_REGISTRY_ENDPOINT=$(echo "$DEPLOYMENT_OUTPUT" | jq -r '.properties.outputs.CONTAINER_REGISTRY_ENDPOINT.value // empty')
        
        if [ -z "$AKS_CLUSTER_NAME" ] || [ "$AKS_CLUSTER_NAME" = "null" ]; then
          echo "âŒ Failed to get AKS cluster name from deployment outputs"
          echo "Raw deployment output:"
          echo "$DEPLOYMENT_OUTPUT" | jq '.'
          echo ""
          echo "Available outputs:"
          echo "$DEPLOYMENT_OUTPUT" | jq '.properties.outputs // {}'
          exit 1
        fi
        
        # Set outputs
        echo "AKS_CLUSTER_NAME=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
        echo "AZURE_RESOURCE_GROUP=${{ env.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
        echo "CONTAINER_REGISTRY_ENDPOINT=$CONTAINER_REGISTRY_ENDPOINT" >> $GITHUB_OUTPUT
        echo "DEPLOYMENT_METHOD=cli" >> $GITHUB_OUTPUT
        
        echo "âœ… Infrastructure deployed successfully!"
        echo "   AKS Cluster: $AKS_CLUSTER_NAME"
        echo "   Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
        echo "   Container Registry: $CONTAINER_REGISTRY_ENDPOINT"

    - name: Set Infrastructure Outputs
      id: deploy-infra
      run: |
        # Combine outputs from either deployment method
        if [ "${{ steps.deploy-infra-azd.outputs.AKS_CLUSTER_NAME }}" != "" ]; then
          echo "AKS_CLUSTER_NAME=${{ steps.deploy-infra-azd.outputs.AKS_CLUSTER_NAME }}" >> $GITHUB_OUTPUT
          echo "AZURE_RESOURCE_GROUP=${{ steps.deploy-infra-azd.outputs.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
          echo "CONTAINER_REGISTRY_ENDPOINT=${{ steps.deploy-infra-azd.outputs.CONTAINER_REGISTRY_ENDPOINT }}" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
          echo "Used AZD for deployment" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ steps.deploy-infra-cli.outputs.AKS_CLUSTER_NAME }}" != "" ] && [ "${{ steps.deploy-infra-cli.outputs.AKS_CLUSTER_NAME }}" != "null" ]; then
          echo "AKS_CLUSTER_NAME=${{ steps.deploy-infra-cli.outputs.AKS_CLUSTER_NAME }}" >> $GITHUB_OUTPUT
          echo "AZURE_RESOURCE_GROUP=${{ steps.deploy-infra-cli.outputs.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
          echo "CONTAINER_REGISTRY_ENDPOINT=${{ steps.deploy-infra-cli.outputs.CONTAINER_REGISTRY_ENDPOINT }}" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
          echo "Used Azure CLI for deployment (AZD fallback)" >> $GITHUB_STEP_SUMMARY
        else
          echo "âŒ Both AZD and Azure CLI deployments failed or returned empty cluster name" >> $GITHUB_STEP_SUMMARY
          echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Display final results
        echo "Final deployment outputs:"
        echo "  AKS Cluster: $([ '${{ steps.deploy-infra-azd.outputs.AKS_CLUSTER_NAME }}' != '' ] && echo '${{ steps.deploy-infra-azd.outputs.AKS_CLUSTER_NAME }}' || echo '${{ steps.deploy-infra-cli.outputs.AKS_CLUSTER_NAME }}')"
        echo "  Resource Group: $([ '${{ steps.deploy-infra-azd.outputs.AZURE_RESOURCE_GROUP }}' != '' ] && echo '${{ steps.deploy-infra-azd.outputs.AZURE_RESOURCE_GROUP }}' || echo '${{ steps.deploy-infra-cli.outputs.AZURE_RESOURCE_GROUP }}')"
        echo "  Container Registry: $([ '${{ steps.deploy-infra-azd.outputs.CONTAINER_REGISTRY_ENDPOINT }}' != '' ] && echo '${{ steps.deploy-infra-azd.outputs.CONTAINER_REGISTRY_ENDPOINT }}' || echo '${{ steps.deploy-infra-cli.outputs.CONTAINER_REGISTRY_ENDPOINT }}')"

    - name: Get AKS credentials
      if: steps.deploy-infra.outputs.DEPLOYMENT_SUCCESS == 'true'
      run: |
        echo "ðŸ”‘ Getting AKS credentials..."
        echo "Cluster: ${{ steps.deploy-infra.outputs.AKS_CLUSTER_NAME }}"
        echo "Resource Group: ${{ steps.deploy-infra.outputs.AZURE_RESOURCE_GROUP }}"
        
        az aks get-credentials \
          --resource-group ${{ steps.deploy-infra.outputs.AZURE_RESOURCE_GROUP }} \
          --name ${{ steps.deploy-infra.outputs.AKS_CLUSTER_NAME }} \
          --overwrite-existing

    - name: Verify AKS connection
      if: steps.deploy-infra.outputs.DEPLOYMENT_SUCCESS == 'true'
      run: |
        kubectl cluster-info
        kubectl get nodes

  # Deploy Zabbix Application
  deploy-zabbix:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure CLI Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group }} \
          --name ${{ needs.deploy-infrastructure.outputs.aks-cluster-name }} \
          --overwrite-existing

    - name: Install NGINX Ingress Controller
      run: |
        # Add NGINX Ingress Helm repository
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo update
        
        # Install NGINX Ingress Controller
        helm install ingress-nginx ingress-nginx/ingress-nginx \
          --namespace ingress-nginx \
          --create-namespace \
          --set controller.replicaCount=2 \
          --set controller.service.type=LoadBalancer \
          --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz \
          --wait

    - name: Deploy Zabbix Namespace and Configuration
      run: |
        kubectl apply -f k8s/zabbix-config.yaml
        kubectl get namespace zabbix

    - name: Deploy MySQL Database
      run: |
        kubectl apply -f k8s/zabbix-mysql.yaml
        
        # Wait for MySQL to be ready
        kubectl wait --for=condition=ready pod -l app=zabbix-mysql -n zabbix --timeout=300s

    - name: Initialize Zabbix Database
      run: |
        # Wait for MySQL pod to be running
        kubectl wait --for=condition=ready pod -l app=zabbix-mysql -n zabbix --timeout=300s
        
        # Get MySQL pod name
        MYSQL_POD=$(kubectl get pods -n zabbix -l app=zabbix-mysql -o jsonpath='{.items[0].metadata.name}')
        
        # Download and import Zabbix schema
        kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "CREATE DATABASE IF NOT EXISTS zabbix CHARACTER SET utf8 COLLATE utf8_bin;"
        kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "GRANT ALL PRIVILEGES ON zabbix.* TO 'zabbix'@'%' IDENTIFIED BY 'zabbix123!';"
        kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "FLUSH PRIVILEGES;"

    - name: Deploy Zabbix Server Components
      run: |
        # Deploy Java Gateway first
        kubectl apply -f k8s/zabbix-additional.yaml
        kubectl wait --for=condition=available deployment/zabbix-java-gateway -n zabbix --timeout=300s
        
        # Deploy Zabbix Server
        kubectl apply -f k8s/zabbix-server.yaml
        kubectl wait --for=condition=available deployment/zabbix-server -n zabbix --timeout=300s

    - name: Deploy Zabbix Web Interface
      run: |
        kubectl apply -f k8s/zabbix-web.yaml
        kubectl wait --for=condition=available deployment/zabbix-web -n zabbix --timeout=300s

    - name: Deploy Ingress
      run: |
        kubectl apply -f k8s/zabbix-ingress.yaml
        
        # Wait for ingress to get an IP
        echo "Waiting for ingress to get external IP..."
        kubectl get ingress -n zabbix zabbix-ingress -w &
        sleep 60
        pkill kubectl

    - name: Get Application URLs
      run: |
        echo "=== Deployment Information ==="
        echo "Zabbix Web Interface URLs:"
        
        # Get LoadBalancer IP
        LB_IP=$(kubectl get service -n zabbix zabbix-web-external -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        if [ ! -z "$LB_IP" ]; then
          echo "LoadBalancer IP: http://$LB_IP"
        fi
        
        # Get Ingress information
        echo "Ingress Configuration:"
        kubectl get ingress -n zabbix zabbix-ingress
        
        echo ""
        echo "=== DNS Configuration Required ==="
        echo "Please configure your DNS to point dal2-devmon-mgt.forescout.com to the LoadBalancer IP"
        echo ""
        echo "=== Default Zabbix Credentials ==="
        echo "Username: Admin"
        echo "Password: zabbix"
        echo ""
        echo "=== Important Security Notes ==="
        echo "1. Change default Zabbix admin password immediately"
        echo "2. Update database passwords in production"
        echo "3. Configure SSL certificate for HTTPS"

    - name: Verify Deployment
      run: |
        echo "=== Verifying Zabbix Deployment ==="
        kubectl get all -n zabbix
        
        echo ""
        echo "=== Pod Status ==="
        kubectl get pods -n zabbix -o wide
        
        echo ""
        echo "=== Service Status ==="
        kubectl get services -n zabbix
        
        echo ""
        echo "=== Ingress Status ==="
        kubectl get ingress -n zabbix

  # Security and Post-Deployment
  post-deployment:
    needs: [deploy-infrastructure, deploy-zabbix]
    runs-on: ubuntu-latest
    if: success()
    
    steps:
    - name: Azure CLI Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Configure Network Security
      run: |
        # Update NSG rules if needed
        echo "Configuring network security rules..."
        
        # Example: Restrict SSH access to specific IP ranges
        # az network nsg rule update \
        #   --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group }} \
        #   --nsg-name nsg-aks-* \
        #   --name AllowSSH \
        #   --source-address-prefixes "YOUR-OFFICE-IP/32"

    - name: Setup Monitoring and Alerts
      run: |
        echo "Setting up monitoring and alerts..."
        # Add any monitoring configuration here

    - name: Generate Deployment Report
      run: |
        echo "=== Deployment Summary Report ===" > deployment-report.md
        echo "**Date:** $(date)" >> deployment-report.md
        echo "**Environment:** Production" >> deployment-report.md
        echo "**AKS Cluster:** ${{ needs.deploy-infrastructure.outputs.aks-cluster-name }}" >> deployment-report.md
        echo "**Resource Group:** ${{ needs.deploy-infrastructure.outputs.resource-group }}" >> deployment-report.md
        echo "**Container Registry:** ${{ needs.deploy-infrastructure.outputs.container-registry }}" >> deployment-report.md
        echo "" >> deployment-report.md
        echo "**Next Steps:**" >> deployment-report.md
        echo "1. Configure DNS for dal2-devmon-mgt.forescout.com" >> deployment-report.md
        echo "2. Upload SSL certificate" >> deployment-report.md
        echo "3. Change default passwords" >> deployment-report.md
        echo "4. Configure Zabbix monitoring templates" >> deployment-report.md
        
        cat deployment-report.md

    - name: Upload Deployment Report
      uses: actions/upload-artifact@v3
      with:
        name: deployment-report
        path: deployment-report.md
