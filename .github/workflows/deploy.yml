name: Deploy AKS Zabbix Infrastructure

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      deployment_type:
        description: 'Type of deployment'
        required: true
        default: 'full'
        type: choice
        options:
        - full
        - infrastructure-only
        - application-only
        - redeploy-clean
      force_powershell:
        description: 'Force PowerShell deployment (skip Azure CLI)'
        required: false
        default: false
        type: boolean
      reset_database:
        description: 'Reset Zabbix database (WARNING: destroys data)'
        required: false
        default: false
        type: boolean
      environment_suffix:
        description: 'Environment suffix (optional)'
        required: false
        default: ''
        type: string
      debug_mode:
        description: 'Enable debug logging'
        required: false
        default: false
        type: boolean

env:
  AZURE_RESOURCE_GROUP: 'Devops-Test'
  AZURE_LOCATION: 'eastus'
  AZURE_SUBSCRIPTION_ID: 'd9b2a1cf-f99b-4f9e-a6cf-c79a078406bf'
  DEPLOYMENT_TYPE: ${{ github.event.inputs.deployment_type || 'full' }}
  FORCE_POWERSHELL: ${{ github.event.inputs.force_powershell || 'false' }}
  RESET_DATABASE: ${{ github.event.inputs.reset_database || 'false' }}
  DEBUG_MODE: ${{ github.event.inputs.debug_mode || 'false' }}
  ENV_SUFFIX: ${{ github.event.inputs.environment_suffix || '' }}

jobs:
  # Infrastructure Deployment
  deploy-infrastructure:
    runs-on: ubuntu-latest
    environment: production
    if: ${{ github.event.inputs.deployment_type == 'full' || github.event.inputs.deployment_type == 'infrastructure-only' || github.event.inputs.deployment_type == 'redeploy-clean' || github.event.inputs.deployment_type == '' || github.event.inputs.deployment_type == null }}
    outputs:
      aks-cluster-name: ${{ steps.deploy-infra.outputs.AKS_CLUSTER_NAME }}
      resource-group: ${{ steps.deploy-infra.outputs.AZURE_RESOURCE_GROUP }}
      container-registry: ${{ steps.deploy-infra.outputs.CONTAINER_REGISTRY_ENDPOINT }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Display Deployment Configuration
      run: |
        echo "=== Deployment Configuration ==="
        echo "Deployment Type: ${{ github.event.inputs.deployment_type || 'full' }}"
        echo "Force PowerShell: ${{ github.event.inputs.force_powershell || 'false' }}"
        echo "Reset Database: ${{ github.event.inputs.reset_database || 'false' }}"
        echo "Debug Mode: ${{ github.event.inputs.debug_mode || 'false' }}"
        echo "Environment Suffix: ${{ github.event.inputs.environment_suffix || 'none' }}"
        echo "Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
        echo "Location: ${{ env.AZURE_LOCATION }}"
        echo "Run Number: ${{ github.run_number }}"
        echo "Actor: ${{ github.actor }}"
        echo "Triggered by: ${{ github.event_name }}"
        
        if [ "${{ github.event.inputs.debug_mode }}" = "true" ]; then
          echo "DEBUG_MODE=true" >> $GITHUB_ENV
          echo "üêõ Debug mode enabled - detailed logging will be provided"
        fi

    - name: Azure CLI Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set up Azure CLI
      run: |
        az account set --subscription ${{ env.AZURE_SUBSCRIPTION_ID }}
        az account show

    - name: Install AZD (with fallback)
      run: |
        echo "üîß Installing Azure Developer CLI..."
        
        # Try multiple installation methods
        if ! command -v azd &> /dev/null; then
          echo "Method 1: Trying direct download..."
          if curl -fsSL https://aka.ms/install-azd.sh | bash; then
            echo "‚úÖ AZD installed via aka.ms script"
          else
            echo "‚ùå Method 1 failed, trying alternative..."
            
            # Alternative: Install via package manager
            echo "Method 2: Installing via package manager..."
            curl -sL https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/microsoft.gpg > /dev/null
            echo "deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/microsoft.gpg] https://packages.microsoft.com/repos/azure-cli/ $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/azure-cli.list
            sudo apt-get update
            sudo apt-get install -y azure-dev-cli || {
              echo "‚ùå Package manager installation failed"
              
              # Final fallback: Use Azure CLI for deployment instead
              echo "‚ö†Ô∏è AZD installation failed, will use Azure CLI for deployment"
              echo "AZD_AVAILABLE=false" >> $GITHUB_ENV
            }
          fi
        else
          echo "‚úÖ AZD already available"
          echo "AZD_AVAILABLE=true" >> $GITHUB_ENV
        fi
        
        # Verify installation
        if command -v azd &> /dev/null; then
          echo "AZD_AVAILABLE=true" >> $GITHUB_ENV
          azd version
        else
          echo "AZD_AVAILABLE=false" >> $GITHUB_ENV
        fi

    - name: Initialize and Configure AZD Environment
      if: env.AZD_AVAILABLE == 'true'
      run: |
        echo "üîß Initializing AZD environment..."
        
        # Initialize AZD environment with DevOps naming convention
        ENV_SUFFIX="${{ github.event.inputs.environment_suffix }}"
        if [ -n "$ENV_SUFFIX" ]; then
          ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}-$ENV_SUFFIX"
        else
          ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}"
        fi
        echo "Environment name: $ENV_NAME"
        echo "This will create resources with naming pattern: resourcename-devops-${{ env.AZURE_LOCATION }}"
        
        # Initialize the environment non-interactively
        azd env new "$ENV_NAME" --location "${{ env.AZURE_LOCATION }}" --subscription "${{ env.AZURE_SUBSCRIPTION_ID }}"
        
        # Select the environment
        azd env select "$ENV_NAME"
        
        # Set additional environment variables
        azd env set AZURE_RESOURCE_GROUP "${{ env.AZURE_RESOURCE_GROUP }}"
        # Skip AZURE_PRINCIPAL_ID for service principal authentication
        # azd env set AZURE_PRINCIPAL_ID "$(az ad signed-in-user show --query id -o tsv)"
        azd env set AZURE_RESOURCE_TOKEN "$(echo $RANDOM | md5sum | head -c 8)"
        
        # Authenticate AZD using the service principal (inherit from Azure CLI)
        echo "üîê Configuring AZD authentication..."
        
        # Skip AZD authentication for now and rely on Azure CLI fallback
        # AZD in GitHub Actions has issues with service principal authentication
        echo "‚ö†Ô∏è AZD authentication skipped - using Azure CLI fallback for reliability"
        echo "AZD_AUTH_FAILED=true" >> $GITHUB_ENV
        
        echo "‚úÖ AZD environment configured successfully"

    - name: Provision Infrastructure with AZD
      id: deploy-infra-azd
      if: env.AZD_AVAILABLE == 'true' && env.AZD_AUTH_FAILED != 'true'
      continue-on-error: true
      run: |
        echo "üöÄ Deploying infrastructure using Azure Developer CLI..."
        
        # Show current environment for debugging
        azd env list
        azd env get-values
        
        # Deploy with verbose output
        if azd provision --no-prompt --debug; then
          echo "‚úÖ AZD deployment successful"
          
          # Capture outputs
          echo "AKS_CLUSTER_NAME=$(azd env get-value AKS_CLUSTER_NAME)" >> $GITHUB_OUTPUT
          echo "AZURE_RESOURCE_GROUP=$(azd env get-value AZURE_RESOURCE_GROUP)" >> $GITHUB_OUTPUT
          echo "CONTAINER_REGISTRY_ENDPOINT=$(azd env get-value CONTAINER_REGISTRY_ENDPOINT)" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_METHOD=azd" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
        else
          echo "‚ùå AZD deployment failed, will fall back to Azure CLI"
          echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_OUTPUT
        fi

    - name: Pre-deployment Diagnostics
      if: steps.deploy-infra-azd.outputs.DEPLOYMENT_SUCCESS != 'true'
      run: |
        echo "üîç Running pre-deployment diagnostics..."
        
        # Check resource group access
        echo "Checking resource group access..."
        az group show --name ${{ env.AZURE_RESOURCE_GROUP }} --output table || {
          echo "‚ùå Cannot access resource group ${{ env.AZURE_RESOURCE_GROUP }}"
          exit 1
        }
        
        # Check resource providers
        echo "Checking required resource providers..."
        REQUIRED_PROVIDERS="Microsoft.ContainerService Microsoft.Network Microsoft.ContainerRegistry Microsoft.ManagedIdentity Microsoft.OperationalInsights"
        for provider in $REQUIRED_PROVIDERS; do
          STATUS=$(az provider show --namespace $provider --query registrationState -o tsv)
          echo "  $provider: $STATUS"
          if [ "$STATUS" != "Registered" ]; then
            echo "‚ö†Ô∏è Registering provider $provider..."
            az provider register --namespace $provider --wait
          fi
        done
        
        # Check for naming conflicts with new DevOps naming convention
        echo "Checking for potential resource naming conflicts..."
        ENV_SUFFIX="${{ github.event.inputs.environment_suffix }}"
        if [ -n "$ENV_SUFFIX" ]; then
          ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}-$ENV_SUFFIX"
        else
          ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}"
        fi
        POTENTIAL_ACR_NAME="acr${ENV_NAME//-/}devops${{ env.AZURE_LOCATION }}"
        
        echo "Environment name: $ENV_NAME"
        echo "Potential ACR name: $POTENTIAL_ACR_NAME"
        echo "Resources will use naming pattern: resourcename-devops-${{ env.AZURE_LOCATION }}"
        
        # Check if ACR name is available
        if az acr check-name --name "$POTENTIAL_ACR_NAME" --query nameAvailable -o tsv | grep -q "false"; then
          echo "‚ö†Ô∏è ACR name $POTENTIAL_ACR_NAME may not be available"
        else
          echo "‚úÖ ACR name appears to be available"
        fi

    - name: Validate Bicep Template
      if: steps.deploy-infra-azd.outputs.DEPLOYMENT_SUCCESS != 'true'
      run: |
        echo "üîç Validating Bicep template..."
        
        # First, validate the template syntax
        echo "Checking template syntax..."
        az bicep build --file infra/main.bicep --stdout > /dev/null || {
          echo "‚ùå Bicep template has syntax errors"
          exit 1
        }
        echo "‚úÖ Template syntax is valid"
        
        # Run what-if analysis to see what would be deployed
        echo "Running what-if analysis..."
        DEPLOYMENT_NAME="zabbix-validation-${{ github.run_number }}"
        
        # Generate environment name with DevOps naming convention
        ENV_SUFFIX="${{ github.event.inputs.environment_suffix }}"
        if [ -n "$ENV_SUFFIX" ]; then
          DEPLOYMENT_ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}-$ENV_SUFFIX"
        else
          DEPLOYMENT_ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}"
        fi
        echo "Deployment environment name: $DEPLOYMENT_ENV_NAME"
        echo "Resources will be named with pattern: resourcename-devops-${{ env.AZURE_LOCATION }}"
        
        # Use what-if to validate without deploying
        az deployment group what-if \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --template-file infra/main.bicep \
          --parameters environmentName="$DEPLOYMENT_ENV_NAME" \
                       location="${{ env.AZURE_LOCATION }}" \
          --name "$DEPLOYMENT_NAME" || {
          echo "‚ùå What-if analysis failed"
          exit 1
        }
        echo "‚úÖ What-if analysis completed successfully"

    - name: Provision Infrastructure with Azure CLI (Fallback)
      id: deploy-infra-cli
      if: steps.deploy-infra-azd.outputs.DEPLOYMENT_SUCCESS != 'true'
      run: |
        echo "üöÄ Deploying infrastructure using Azure CLI (AZD fallback)..."
        
        # Generate environment name with DevOps naming convention
        ENV_SUFFIX="${{ github.event.inputs.environment_suffix }}"
        if [ -n "$ENV_SUFFIX" ]; then
          DEPLOYMENT_ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}-$ENV_SUFFIX"
        else
          DEPLOYMENT_ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}"
        fi
        echo "Deployment environment name: $DEPLOYMENT_ENV_NAME"
        echo "Resources will be named with pattern: resourcename-devops-${{ env.AZURE_LOCATION }}"
        
        # Generate deployment name with timestamp to avoid conflicts
        TIMESTAMP=$(date +%s)
        DEPLOYMENT_NAME="zabbix-deploy-${{ github.run_number }}-$TIMESTAMP"
        echo "Deployment name: $DEPLOYMENT_NAME"
        
        # Deploy Bicep template with improved error handling and retry logic
        echo "üèóÔ∏è Deploying Bicep template..."
        echo "‚ÑπÔ∏è Deploying with service principal authentication (no user principal ID needed)"
        
        # Function to attempt deployment with retry logic
        deploy_with_retry() {
          local attempt=1
          local max_attempts=3
          local delay=30
          
          while [ $attempt -le $max_attempts ]; do
            echo "üîÑ Deployment attempt $attempt of $max_attempts..."
            
            # Clear only specific cache files to avoid "content consumed" errors
            # But preserve authentication tokens
            rm -rf ~/.azure/commandIndex.json ~/.azure/telemetry.txt 2>/dev/null || true
            
            # Verify authentication without clearing auth tokens
            echo "üîê Verifying Azure authentication..."
            if ! az account show --output none 2>/dev/null; then
              echo "‚ùå Authentication lost, re-authenticating with service principal..."
              # Re-authenticate using the stored credentials
              CLIENT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .clientId)
              CLIENT_SECRET=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .clientSecret)
              TENANT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .tenantId)
              
              az login \
                --service-principal \
                --username "$CLIENT_ID" \
                --password "$CLIENT_SECRET" \
                --tenant "$TENANT_ID" > /dev/null
              
              # Set the subscription
              az account set --subscription "${{ env.AZURE_SUBSCRIPTION_ID }}"
              echo "‚úÖ Re-authentication successful"
            else
              echo "‚úÖ Authentication verified"
            fi
            
            # Set deployment timeout and try deployment
            export AZURE_HTTP_USER_AGENT="GitHub-Actions-Zabbix-Deploy"
            
            set +e  # Don't exit on error
            DEPLOYMENT_OUTPUT=$(timeout 1800 az deployment group create \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --template-file infra/main.bicep \
              --parameters environmentName="$DEPLOYMENT_ENV_NAME" \
                           location="${{ env.AZURE_LOCATION }}" \
              --name "$DEPLOYMENT_NAME" \
              --mode Incremental \
              --output json \
              --only-show-errors 2>&1)
            DEPLOYMENT_EXIT_CODE=$?
            set -e  # Re-enable exit on error
            
            if [ $DEPLOYMENT_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Deployment successful on attempt $attempt"
              echo "$DEPLOYMENT_OUTPUT"
              return 0
            else
              echo "‚ùå Deployment attempt $attempt failed with exit code $DEPLOYMENT_EXIT_CODE"
              echo "Error output:"
              echo "$DEPLOYMENT_OUTPUT"
              
              # Check for specific "content consumed" error and set flag for immediate ARM fallback
              if echo "$DEPLOYMENT_OUTPUT" | grep -i "content.*already.*consumed"; then
                echo "üö® Detected 'content already consumed' error - this is a known Azure CLI session issue"
                echo "‚ö° Setting flag for immediate ARM template fallback..."
                # Set environment variable in outer scope
                export BICEP_FAILED_CONTENT_ERROR=true
                echo "BICEP_FAILED_CONTENT_ERROR=true" >> $GITHUB_ENV
                echo "‚ùå Bicep deployment failed due to Azure CLI session issue"
                return 1
              fi
              
              # Check if it's a retryable error (other than content consumed)
              if echo "$DEPLOYMENT_OUTPUT" | grep -i "timeout\|network\|connection\|login"; then
                if [ $attempt -lt $max_attempts ]; then
                  echo "‚è≥ Retryable error detected. Waiting ${delay}s before retry..."
                  sleep $delay
                  delay=$((delay * 2))  # Exponential backoff
                  attempt=$((attempt + 1))
                  
                  # Try with a new deployment name to avoid conflicts
                  DEPLOYMENT_NAME="zabbix-deploy-${{ github.run_number }}-$(date +%s)"
                  echo "Using new deployment name: $DEPLOYMENT_NAME"
                  continue
                fi
              fi
              
              echo "‚ùå Non-retryable error or max attempts reached"
              return $DEPLOYMENT_EXIT_CODE
            fi
          done
        }
        
        # Attempt deployment with retry logic
        if ! deploy_with_retry; then
          # Check if this was due to content consumed error (emergency ARM should handle this)
          if [ "${BICEP_FAILED_CONTENT_ERROR:-}" = "true" ]; then
            echo "‚ö° Content consumed error detected - skipping final diagnostics"
            echo "üîÑ Emergency ARM template deployment will handle this..."
            echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_OUTPUT
            echo "DEPLOYMENT_METHOD=failed-content-consumed" >> $GITHUB_OUTPUT
            exit 0  # Exit gracefully to allow emergency ARM deployment
          fi
          
          echo ""
          echo "‚ùå All deployment attempts failed. Running final diagnostics..."
          
          # Try validation as a last resort to get better error info
          echo "Running template validation for error details..."
          az deployment group validate \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --template-file infra/main.bicep \
            --parameters environmentName="$DEPLOYMENT_ENV_NAME" \
                         location="${{ env.AZURE_LOCATION }}" \
            --output json 2>&1 | jq '.' || echo "Validation also failed"
          
          exit 1
        fi
        
        # Extract outputs with validation
        echo "üìã Extracting deployment outputs..."
        if ! echo "$DEPLOYMENT_OUTPUT" | jq . > /dev/null 2>&1; then
          echo "‚ùå Deployment output is not valid JSON"
          echo "Raw output:"
          echo "$DEPLOYMENT_OUTPUT"
          exit 1
        fi
        
        AKS_CLUSTER_NAME=$(echo "$DEPLOYMENT_OUTPUT" | jq -r '.properties.outputs.AKS_CLUSTER_NAME.value // empty')
        CONTAINER_REGISTRY_ENDPOINT=$(echo "$DEPLOYMENT_OUTPUT" | jq -r '.properties.outputs.CONTAINER_REGISTRY_ENDPOINT.value // empty')
        
        if [ -z "$AKS_CLUSTER_NAME" ] || [ "$AKS_CLUSTER_NAME" = "null" ]; then
          echo "‚ùå Failed to get AKS cluster name from deployment outputs"
          echo "Raw deployment output:"
          echo "$DEPLOYMENT_OUTPUT" | jq '.'
          echo ""
          echo "Available outputs:"
          echo "$DEPLOYMENT_OUTPUT" | jq '.properties.outputs // {}'
          exit 1
        fi
        
        # Set outputs
        echo "AKS_CLUSTER_NAME=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
        echo "AZURE_RESOURCE_GROUP=${{ env.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
        echo "CONTAINER_REGISTRY_ENDPOINT=$CONTAINER_REGISTRY_ENDPOINT" >> $GITHUB_OUTPUT
        echo "DEPLOYMENT_METHOD=cli" >> $GITHUB_OUTPUT
        echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
        
        echo "‚úÖ Infrastructure deployed successfully!"
        echo "   AKS Cluster: $AKS_CLUSTER_NAME"
        echo "   Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
        echo "   Container Registry: $CONTAINER_REGISTRY_ENDPOINT"

    - name: Emergency ARM Template Deployment (Content Consumed Error)
      id: deploy-infra-arm-emergency
      if: steps.deploy-infra-cli.conclusion == 'failure' && !cancelled()
      run: |
        # Check if the failure was due to content consumed error
        if [ "${BICEP_FAILED_CONTENT_ERROR:-}" = "true" ]; then
          echo "üö® EMERGENCY: Deploying with ARM template due to 'content consumed' error"
          echo "üîÑ This bypasses the Azure CLI Bicep deployment which has session issues"
        else
          echo "‚è≠Ô∏è Skipping emergency ARM deployment - not a content consumed error"
          echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Generate deployment name with timestamp
        TIMESTAMP=$(date +%s)
        ARM_DEPLOYMENT_NAME="zabbix-arm-emergency-${{ github.run_number }}-$TIMESTAMP"
        echo "Emergency ARM Deployment name: $ARM_DEPLOYMENT_NAME"
        
        # Clear Azure CLI cache completely and re-authenticate fresh
        echo "üßπ Performing complete Azure CLI session reset..."
        rm -rf ~/.azure/logs ~/.azure/commandIndex.json ~/.azure/telemetry.txt 2>/dev/null || true
        rm -rf ~/.azure/httpCache ~/.azure/aadCache ~/.azure/msal_cache.json 2>/dev/null || true
        az logout 2>/dev/null || true
        az account clear 2>/dev/null || true
        
        echo "üîê Establishing fresh Azure CLI session for ARM deployment..."
        CLIENT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .clientId)
        CLIENT_SECRET=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .clientSecret)
        TENANT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .tenantId)
        
        az login \
          --service-principal \
          --username "$CLIENT_ID" \
          --password "$CLIENT_SECRET" \
          --tenant "$TENANT_ID" > /dev/null
        
        az account set --subscription "${{ env.AZURE_SUBSCRIPTION_ID }}"
        echo "‚úÖ Fresh session established"
        
        # Deploy ARM template immediately (no retries needed - this usually works)
        echo "üèóÔ∏è Deploying ARM template (emergency fallback)..."
        
        # Generate environment name with DevOps naming convention
        ENV_SUFFIX="${{ github.event.inputs.environment_suffix }}"
        if [ -n "$ENV_SUFFIX" ]; then
          DEPLOYMENT_ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}-$ENV_SUFFIX"
        else
          DEPLOYMENT_ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}"
        fi
        
        set +e  # Don't exit on error
        ARM_DEPLOYMENT_OUTPUT=$(timeout 1800 az deployment group create \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --template-file infra/main-arm.json \
          --parameters environmentName="$DEPLOYMENT_ENV_NAME" \
                       location="${{ env.AZURE_LOCATION }}" \
          --name "$ARM_DEPLOYMENT_NAME" \
          --mode Incremental \
          --output json \
          --only-show-errors 2>&1)
        ARM_DEPLOYMENT_EXIT_CODE=$?
        set -e  # Re-enable exit on error
        
        if [ $ARM_DEPLOYMENT_EXIT_CODE -ne 0 ]; then
          echo "‚ùå Emergency ARM template deployment failed with exit code $ARM_DEPLOYMENT_EXIT_CODE"
          echo "Error output:"
          echo "$ARM_DEPLOYMENT_OUTPUT"
          echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_OUTPUT
        else
          echo "‚úÖ Emergency ARM template deployment successful!"
          
          # Extract outputs
          AKS_CLUSTER_NAME=$(echo "$ARM_DEPLOYMENT_OUTPUT" | jq -r '.properties.outputs.AKS_CLUSTER_NAME.value // empty')
          CONTAINER_REGISTRY_ENDPOINT=$(echo "$ARM_DEPLOYMENT_OUTPUT" | jq -r '.properties.outputs.CONTAINER_REGISTRY_ENDPOINT.value // empty')
          
          if [ -z "$AKS_CLUSTER_NAME" ] || [ "$AKS_CLUSTER_NAME" = "null" ]; then
            echo "‚ùå Failed to get AKS cluster name from emergency ARM deployment outputs"
            echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_OUTPUT
          else
            # Set outputs
            echo "AKS_CLUSTER_NAME=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
            echo "AZURE_RESOURCE_GROUP=${{ env.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
            echo "CONTAINER_REGISTRY_ENDPOINT=$CONTAINER_REGISTRY_ENDPOINT" >> $GITHUB_OUTPUT
            echo "DEPLOYMENT_METHOD=arm-emergency" >> $GITHUB_OUTPUT
            echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
            
            echo "‚úÖ Emergency ARM Infrastructure deployed successfully!"
            echo "   AKS Cluster: $AKS_CLUSTER_NAME"
            echo "   Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
            echo "   Container Registry: $CONTAINER_REGISTRY_ENDPOINT"
          fi
        fi

    - name: Provision Infrastructure with PowerShell (Final Fallback)
      id: deploy-infra-pwsh
      if: steps.deploy-infra-azd.outputs.DEPLOYMENT_SUCCESS != 'true' && steps.deploy-infra-cli.outputs.DEPLOYMENT_SUCCESS != 'true' && steps.deploy-infra-arm-emergency.outputs.DEPLOYMENT_SUCCESS != 'true'
      shell: pwsh
      run: |
        Write-Host "üöÄ Attempting deployment with Azure PowerShell (final fallback)..." -ForegroundColor Cyan
        
        try {
          # Install Azure PowerShell modules if not present
          Write-Host "üì¶ Installing Azure PowerShell modules..." -ForegroundColor Yellow
          if (-not (Get-Module -ListAvailable -Name Az.Accounts)) {
            Install-Module -Name Az -Force -AllowClobber -Scope CurrentUser -Repository PSGallery
          }
          
          # Import required modules
          Import-Module Az.Accounts -Force
          Import-Module Az.Resources -Force
          
          # Parse credentials for PowerShell authentication
          $creds = '${{ secrets.AZURE_CREDENTIALS }}' | ConvertFrom-Json
          $securePassword = ConvertTo-SecureString $creds.clientSecret -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential($creds.clientId, $securePassword)
          
          # Authenticate with Azure PowerShell
          Write-Host "üîê Authenticating with Azure PowerShell..." -ForegroundColor Blue
          $context = Connect-AzAccount -ServicePrincipal -Credential $credential -Tenant $creds.tenantId -Subscription "${{ env.AZURE_SUBSCRIPTION_ID }}"
          Write-Host "‚úÖ Authentication successful" -ForegroundColor Green
          
          # Run the PowerShell deployment script
          $scriptPath = Join-Path $env:GITHUB_WORKSPACE "scripts" "deploy-infrastructure-pwsh.ps1"
          
          if (Test-Path $scriptPath) {
            Write-Host "üöÄ Executing PowerShell deployment script..." -ForegroundColor Cyan
            
            # Generate environment name with DevOps naming convention
            $envSuffix = "${{ github.event.inputs.environment_suffix }}"
            if ([string]::IsNullOrEmpty($envSuffix)) {
              $deploymentEnvName = "zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}"
            } else {
              $deploymentEnvName = "zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}-$envSuffix"
            }
            Write-Host "Deployment environment name: $deploymentEnvName" -ForegroundColor Yellow
            Write-Host "Resources will be named with pattern: resourcename-devops-${{ env.AZURE_LOCATION }}" -ForegroundColor Yellow
            
            & $scriptPath -ResourceGroupName "${{ env.AZURE_RESOURCE_GROUP }}" -Location "${{ env.AZURE_LOCATION }}" -EnvironmentName $deploymentEnvName -SubscriptionId "${{ env.AZURE_SUBSCRIPTION_ID }}"
            
            if ($LASTEXITCODE -eq 0) {
              Write-Host "‚úÖ PowerShell deployment completed successfully!" -ForegroundColor Green
            } else {
              throw "PowerShell deployment script exited with code $LASTEXITCODE"
            }
          } else {
            Write-Host "‚ùå PowerShell deployment script not found at: $scriptPath" -ForegroundColor Red
            exit 1
          }
          
        } catch {
          Write-Host "‚ùå PowerShell deployment failed: $($_.Exception.Message)" -ForegroundColor Red
          Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
          exit 1
        }

    - name: Provision Infrastructure with ARM Template (Alternative Fallback)
      id: deploy-infra-arm
      if: steps.deploy-infra-azd.outputs.DEPLOYMENT_SUCCESS != 'true' && steps.deploy-infra-cli.outputs.DEPLOYMENT_SUCCESS != 'true' && steps.deploy-infra-arm-emergency.outputs.DEPLOYMENT_SUCCESS != 'true'
      run: |
        echo "üöÄ Attempting deployment with ARM template (alternative to Bicep)..."
        
        # Generate deployment name with timestamp
        TIMESTAMP=$(date +%s)
        ARM_DEPLOYMENT_NAME="zabbix-arm-deploy-${{ github.run_number }}-$TIMESTAMP"
        echo "ARM Deployment name: $ARM_DEPLOYMENT_NAME"
        
        # Verify authentication first
        echo "üîê Verifying Azure authentication for ARM deployment..."
        if ! az account show --output none 2>/dev/null; then
          echo "‚ùå Authentication lost, re-authenticating..."
          CLIENT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .clientId)
          CLIENT_SECRET=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .clientSecret)
          TENANT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .tenantId)
          
          az login \
            --service-principal \
            --username "$CLIENT_ID" \
            --password "$CLIENT_SECRET" \
            --tenant "$TENANT_ID" > /dev/null
          az account set --subscription "${{ env.AZURE_SUBSCRIPTION_ID }}"
        fi
        
        # Deploy ARM template with timeout and error handling
        echo "üèóÔ∏è Deploying ARM template..."
        
        # Generate environment name with DevOps naming convention
        ENV_SUFFIX="${{ github.event.inputs.environment_suffix }}"
        if [ -n "$ENV_SUFFIX" ]; then
          DEPLOYMENT_ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}-$ENV_SUFFIX"
        else
          DEPLOYMENT_ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}"
        fi
        
        set +e  # Don't exit on error
        ARM_DEPLOYMENT_OUTPUT=$(timeout 1800 az deployment group create \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --template-file infra/main-arm.json \
          --parameters environmentName="$DEPLOYMENT_ENV_NAME" \
                       location="${{ env.AZURE_LOCATION }}" \
          --name "$ARM_DEPLOYMENT_NAME" \
          --mode Incremental \
          --output json \
          --only-show-errors 2>&1)
        ARM_DEPLOYMENT_EXIT_CODE=$?
        set -e  # Re-enable exit on error
        
        if [ $ARM_DEPLOYMENT_EXIT_CODE -ne 0 ]; then
          echo "‚ùå ARM template deployment failed with exit code $ARM_DEPLOYMENT_EXIT_CODE"
          echo "Error output:"
          echo "$ARM_DEPLOYMENT_OUTPUT"
          echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_OUTPUT
        else
          echo "‚úÖ ARM template deployment successful!"
          
          # Extract outputs
          AKS_CLUSTER_NAME=$(echo "$ARM_DEPLOYMENT_OUTPUT" | jq -r '.properties.outputs.AKS_CLUSTER_NAME.value // empty')
          CONTAINER_REGISTRY_ENDPOINT=$(echo "$ARM_DEPLOYMENT_OUTPUT" | jq -r '.properties.outputs.CONTAINER_REGISTRY_ENDPOINT.value // empty')
          
          if [ -z "$AKS_CLUSTER_NAME" ] || [ "$AKS_CLUSTER_NAME" = "null" ]; then
            echo "‚ùå Failed to get AKS cluster name from ARM deployment outputs"
            echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_OUTPUT
          else
            # Set outputs
            echo "AKS_CLUSTER_NAME=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
            echo "AZURE_RESOURCE_GROUP=${{ env.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
            echo "CONTAINER_REGISTRY_ENDPOINT=$CONTAINER_REGISTRY_ENDPOINT" >> $GITHUB_OUTPUT
            echo "DEPLOYMENT_METHOD=arm" >> $GITHUB_OUTPUT
            echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
            
            echo "‚úÖ ARM Infrastructure deployed successfully!"
            echo "   AKS Cluster: $AKS_CLUSTER_NAME"
            echo "   Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
            echo "   Container Registry: $CONTAINER_REGISTRY_ENDPOINT"
          fi
        fi

    - name: Set Infrastructure Outputs
      id: deploy-infra
      run: |
        # Use outputs from whichever deployment method succeeded
        if [ "${{ steps.deploy-infra-azd.outputs.DEPLOYMENT_SUCCESS }}" = "true" ]; then
          echo "Using AZD deployment outputs"
          echo "AKS_CLUSTER_NAME=${{ steps.deploy-infra-azd.outputs.AKS_CLUSTER_NAME }}" >> $GITHUB_OUTPUT
          echo "AZURE_RESOURCE_GROUP=${{ steps.deploy-infra-azd.outputs.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
          echo "CONTAINER_REGISTRY_ENDPOINT=${{ steps.deploy-infra-azd.outputs.CONTAINER_REGISTRY_ENDPOINT }}" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Used AZD for deployment" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ steps.deploy-infra-cli.outputs.DEPLOYMENT_SUCCESS }}" = "true" ]; then
          echo "Using Azure CLI deployment outputs"
          echo "AKS_CLUSTER_NAME=${{ steps.deploy-infra-cli.outputs.AKS_CLUSTER_NAME }}" >> $GITHUB_OUTPUT
          echo "AZURE_RESOURCE_GROUP=${{ steps.deploy-infra-cli.outputs.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
          echo "CONTAINER_REGISTRY_ENDPOINT=${{ steps.deploy-infra-cli.outputs.CONTAINER_REGISTRY_ENDPOINT }}" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Used Azure CLI for deployment (AZD fallback)" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ steps.deploy-infra-arm-emergency.outputs.DEPLOYMENT_SUCCESS }}" = "true" ]; then
          echo "Using Emergency ARM template deployment outputs"
          echo "AKS_CLUSTER_NAME=${{ steps.deploy-infra-arm-emergency.outputs.AKS_CLUSTER_NAME }}" >> $GITHUB_OUTPUT
          echo "AZURE_RESOURCE_GROUP=${{ steps.deploy-infra-arm-emergency.outputs.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
          echo "CONTAINER_REGISTRY_ENDPOINT=${{ steps.deploy-infra-arm-emergency.outputs.CONTAINER_REGISTRY_ENDPOINT }}" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Used Emergency ARM template for deployment (content consumed error fallback)" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ steps.deploy-infra-pwsh.outputs.DEPLOYMENT_SUCCESS }}" = "true" ]; then
          echo "Using Azure PowerShell deployment outputs"
          echo "AKS_CLUSTER_NAME=${{ steps.deploy-infra-pwsh.outputs.AKS_CLUSTER_NAME }}" >> $GITHUB_OUTPUT
          echo "AZURE_RESOURCE_GROUP=${{ steps.deploy-infra-pwsh.outputs.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
          echo "CONTAINER_REGISTRY_ENDPOINT=${{ steps.deploy-infra-pwsh.outputs.CONTAINER_REGISTRY_ENDPOINT }}" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Used Azure PowerShell for deployment (final fallback)" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ steps.deploy-infra-arm.outputs.DEPLOYMENT_SUCCESS }}" = "true" ]; then
          echo "Using ARM template deployment outputs"
          echo "AKS_CLUSTER_NAME=${{ steps.deploy-infra-arm.outputs.AKS_CLUSTER_NAME }}" >> $GITHUB_OUTPUT
          echo "AZURE_RESOURCE_GROUP=${{ steps.deploy-infra-arm.outputs.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
          echo "CONTAINER_REGISTRY_ENDPOINT=${{ steps.deploy-infra-arm.outputs.CONTAINER_REGISTRY_ENDPOINT }}" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Used ARM template for deployment (alternative fallback)" >> $GITHUB_STEP_SUMMARY
        else
          echo "‚ùå All deployment methods failed or returned empty outputs" >> $GITHUB_STEP_SUMMARY
          echo "AZD success: ${{ steps.deploy-infra-azd.outputs.DEPLOYMENT_SUCCESS }}"
          echo "CLI success: ${{ steps.deploy-infra-cli.outputs.DEPLOYMENT_SUCCESS }}"
          echo "Emergency ARM success: ${{ steps.deploy-infra-arm-emergency.outputs.DEPLOYMENT_SUCCESS }}"
          echo "PowerShell success: ${{ steps.deploy-infra-pwsh.outputs.DEPLOYMENT_SUCCESS }}"
          echo "ARM success: ${{ steps.deploy-infra-arm.outputs.DEPLOYMENT_SUCCESS }}"
          echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: Display Deployment Summary
      run: |
        echo ""
        echo "=== Final Deployment Results ==="
        if [ "${{ steps.deploy-infra-azd.outputs.DEPLOYMENT_SUCCESS }}" = "true" ]; then
          echo "‚úÖ Deployment Method: Azure Developer CLI (AZD)"
          echo "AKS Cluster Name: ${{ steps.deploy-infra-azd.outputs.AKS_CLUSTER_NAME }}"
          echo "Resource Group: ${{ steps.deploy-infra-azd.outputs.AZURE_RESOURCE_GROUP }}"
          echo "Container Registry: ${{ steps.deploy-infra-azd.outputs.CONTAINER_REGISTRY_ENDPOINT }}"
        elif [ "${{ steps.deploy-infra-cli.outputs.DEPLOYMENT_SUCCESS }}" = "true" ]; then
          echo "‚úÖ Deployment Method: Azure CLI (Fallback)"
          echo "AKS Cluster Name: ${{ steps.deploy-infra-cli.outputs.AKS_CLUSTER_NAME }}"
          echo "Resource Group: ${{ steps.deploy-infra-cli.outputs.AZURE_RESOURCE_GROUP }}"
          echo "Container Registry: ${{ steps.deploy-infra-cli.outputs.CONTAINER_REGISTRY_ENDPOINT }}"
        elif [ "${{ steps.deploy-infra-arm-emergency.outputs.DEPLOYMENT_SUCCESS }}" = "true" ]; then
          echo "‚úÖ Deployment Method: Emergency ARM Template (Content Consumed Error Fallback)"
          echo "AKS Cluster Name: ${{ steps.deploy-infra-arm-emergency.outputs.AKS_CLUSTER_NAME }}"
          echo "Resource Group: ${{ steps.deploy-infra-arm-emergency.outputs.AZURE_RESOURCE_GROUP }}"
          echo "Container Registry: ${{ steps.deploy-infra-arm-emergency.outputs.CONTAINER_REGISTRY_ENDPOINT }}"
        elif [ "${{ steps.deploy-infra-pwsh.outputs.DEPLOYMENT_SUCCESS }}" = "true" ]; then
          echo "‚úÖ Deployment Method: Azure PowerShell (Final Fallback)"
          echo "AKS Cluster Name: ${{ steps.deploy-infra-pwsh.outputs.AKS_CLUSTER_NAME }}"
          echo "Resource Group: ${{ steps.deploy-infra-pwsh.outputs.AZURE_RESOURCE_GROUP }}"
          echo "Container Registry: ${{ steps.deploy-infra-pwsh.outputs.CONTAINER_REGISTRY_ENDPOINT }}"
        elif [ "${{ steps.deploy-infra-arm.outputs.DEPLOYMENT_SUCCESS }}" = "true" ]; then
          echo "‚úÖ Deployment Method: ARM Template (Alternative Fallback)"
          echo "AKS Cluster Name: ${{ steps.deploy-infra-arm.outputs.AKS_CLUSTER_NAME }}"
          echo "Resource Group: ${{ steps.deploy-infra-arm.outputs.AZURE_RESOURCE_GROUP }}"
          echo "Container Registry: ${{ steps.deploy-infra-arm.outputs.CONTAINER_REGISTRY_ENDPOINT }}"
        else
          echo "‚ùå No successful deployment to display"
        fi

    - name: Get AKS credentials
      if: steps.deploy-infra.outputs.DEPLOYMENT_SUCCESS == 'true'
      run: |
        echo "üîë Getting AKS credentials..."
        echo "Cluster: ${{ steps.deploy-infra.outputs.AKS_CLUSTER_NAME }}"
        echo "Resource Group: ${{ steps.deploy-infra.outputs.AZURE_RESOURCE_GROUP }}"
        
        az aks get-credentials \
          --resource-group ${{ steps.deploy-infra.outputs.AZURE_RESOURCE_GROUP }} \
          --name ${{ steps.deploy-infra.outputs.AKS_CLUSTER_NAME }} \
          --overwrite-existing

    - name: Verify AKS connection
      if: steps.deploy-infra.outputs.DEPLOYMENT_SUCCESS == 'true'
      run: |
        kubectl cluster-info
        kubectl get nodes

  # Deploy Zabbix Application
  deploy-zabbix:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    environment: production
    if: ${{ always() && (github.event.inputs.deployment_type == 'full' || github.event.inputs.deployment_type == 'application-only' || github.event.inputs.deployment_type == 'redeploy-clean' || github.event.inputs.deployment_type == '' || github.event.inputs.deployment_type == null) && (needs.deploy-infrastructure.result == 'success' || github.event.inputs.deployment_type == 'application-only') }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure CLI Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group }} \
          --name ${{ needs.deploy-infrastructure.outputs.aks-cluster-name }} \
          --overwrite-existing

    - name: Install NGINX Ingress Controller
      run: |
        # Add NGINX Ingress Helm repository
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo update
        
        # Install NGINX Ingress Controller
        helm install ingress-nginx ingress-nginx/ingress-nginx \
          --namespace ingress-nginx \
          --create-namespace \
          --set controller.replicaCount=2 \
          --set controller.service.type=LoadBalancer \
          --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz \
          --wait

    - name: Deploy Zabbix Namespace and Configuration
      run: |
        kubectl apply -f k8s/zabbix-config.yaml
        kubectl get namespace zabbix

    - name: Cleanup Existing Zabbix Resources (Conditional)
      if: ${{ github.event.inputs.deployment_type == 'redeploy-clean' || github.event.inputs.reset_database == 'true' }}
      run: |
        echo "üßπ Cleaning up existing Zabbix resources for fresh deployment..."
        echo "Deployment Type: ${{ github.event.inputs.deployment_type }}"
        echo "Reset Database: ${{ github.event.inputs.reset_database }}"
        
        # Delete Zabbix deployments and services
        kubectl delete deployment,service,ingress,configmap,secret -n zabbix --all --ignore-not-found=true
        
        # Wait for pods to terminate
        kubectl wait --for=delete pods --all -n zabbix --timeout=120s || true
        
        # Clean up PVCs if database reset is requested
        if [ "${{ github.event.inputs.reset_database }}" = "true" ]; then
          echo "‚ö†Ô∏è RESETTING DATABASE - All data will be lost!"
          kubectl delete pvc -n zabbix --all --ignore-not-found=true
        fi
        
        echo "‚úÖ Cleanup completed"

    - name: Smart Cleanup for Regular Deployments
      if: ${{ github.event.inputs.deployment_type != 'redeploy-clean' && github.event.inputs.reset_database != 'true' }}
      run: |
        echo "üîÑ Performing smart cleanup (preserving data)..."
        
        # Only delete deployments and services, keep PVCs and secrets
        kubectl delete deployment,service,ingress -n zabbix --ignore-not-found=true
        
        # Wait for pods to terminate
        kubectl wait --for=delete pods -l app!=zabbix-mysql -n zabbix --timeout=60s || true
        
        echo "‚úÖ Smart cleanup completed - data preserved"

    - name: Deploy MySQL Database
      run: |
        kubectl apply -f k8s/zabbix-mysql.yaml
        
        # Wait for MySQL to be ready
        kubectl wait --for=condition=ready pod -l app=zabbix-mysql -n zabbix --timeout=600s

    - name: Initialize Zabbix Database with Complete Setup
      run: |
        echo "üóÑÔ∏è Initializing Zabbix database with complete schema and users..."
        
        # Wait for MySQL pod to be running
        kubectl wait --for=condition=ready pod -l app=zabbix-mysql -n zabbix --timeout=300s
        
        # Get MySQL pod name
        MYSQL_POD=$(kubectl get pods -n zabbix -l app=zabbix-mysql -o jsonpath='{.items[0].metadata.name}')
        echo "MySQL Pod: $MYSQL_POD"
        
        # Check if database exists and has data
        DB_EXISTS=$(kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='zabbix';" 2>/dev/null | tail -n 1 || echo "0")
        
        # Force database reset if requested
        if [ "${{ github.event.inputs.reset_database }}" = "true" ]; then
          echo "‚ö†Ô∏è Force database reset requested - dropping existing database"
          DB_EXISTS="0"
        fi
        
        if [ "$DB_EXISTS" -gt "10" ]; then
          echo "‚úÖ Zabbix database already exists with $DB_EXISTS tables"
          if [ "${{ github.event.inputs.debug_mode }}" = "true" ]; then
            echo "üêõ Existing tables:"
            kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "SHOW TABLES FROM zabbix;" || true
          fi
          echo "Skipping database initialization"
        else
          echo "üîß Setting up fresh Zabbix database..."
          
          # Create database and user
          kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "DROP DATABASE IF EXISTS zabbix;"
          kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "CREATE DATABASE zabbix CHARACTER SET utf8 COLLATE utf8_bin;"
          kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "GRANT ALL PRIVILEGES ON zabbix.* TO 'zabbix'@'%' IDENTIFIED BY 'zabbix123!';"
          kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "FLUSH PRIVILEGES;"
          
          # Apply the database initialization job for complete schema setup
          kubectl apply -f k8s/zabbix-db-init-direct.yaml
          
          # Wait for initialization job to complete
          kubectl wait --for=condition=complete job/zabbix-db-init -n zabbix --timeout=600s || {
            echo "‚ö†Ô∏è Database initialization job didn't complete, checking logs..."
            kubectl logs job/zabbix-db-init -n zabbix || true
            echo "Continuing with manual setup..."
          }
          
          # Verify database schema was created
          TABLE_COUNT=$(kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='zabbix';" 2>/dev/null | tail -n 1 || echo "0")
          echo "Database tables created: $TABLE_COUNT"
          
          if [ "$TABLE_COUNT" -lt "10" ]; then
            echo "‚ùå Database initialization failed, manual intervention required"
            exit 1
          fi
          
          # Ensure admin user exists
          ADMIN_EXISTS=$(kubectl exec -n zabbix $MYSQL_POD -- mysql -u zabbix -pzabbix123! zabbix -e "SELECT COUNT(*) FROM users WHERE username='Admin';" 2>/dev/null | tail -n 1 || echo "0")
          
          if [ "$ADMIN_EXISTS" -eq "0" ]; then
            echo "üîß Creating default Admin user..."
            kubectl exec -n zabbix $MYSQL_POD -- mysql -u zabbix -pzabbix123! zabbix -e "
              INSERT INTO users (userid, username, name, surname, passwd, url, autologin, autologout, lang, refresh, theme, attempt_failed, attempt_ip, attempt_clock, rows_per_page)
              VALUES (1, 'Admin', 'Zabbix', 'Administrator', '5fce1b3e34b520afeffb37ce08c7cd66', '', 1, '15m', 'en_US', '30s', 'default', 0, '', 0, 50)
              ON DUPLICATE KEY UPDATE passwd='5fce1b3e34b520afeffb37ce08c7cd66';
            "
            
            # Ensure Super Admin role exists and is assigned
            kubectl exec -n zabbix $MYSQL_POD -- mysql -u zabbix -pzabbix123! zabbix -e "
              INSERT IGNORE INTO role (roleid, name, type, readonly) VALUES (3, 'Super admin role', 3, 1);
              INSERT IGNORE INTO user_role (userid, roleid) VALUES (1, 3);
            "
            
            echo "‚úÖ Admin user created with default password 'zabbix'"
          fi
          
          # Create guest user and role
          kubectl exec -n zabbix $MYSQL_POD -- mysql -u zabbix -pzabbix123! zabbix -e "
            INSERT IGNORE INTO users (userid, username, name, surname, passwd, url, autologin, autologout, lang, refresh, theme, attempt_failed, attempt_ip, attempt_clock, rows_per_page)
            VALUES (2, 'guest', '', '', 'd41d8cd98f00b204e9800998ecf8427e', '', 0, '15m', 'en_US', '30s', 'default', 0, '', 0, 50);
            
            INSERT IGNORE INTO role (roleid, name, type, readonly) VALUES (1, 'Guest role', 1, 1);
            INSERT IGNORE INTO user_role (userid, roleid) VALUES (2, 1);
            
            INSERT IGNORE INTO usrgrp (usrgrpid, name, gui_access, users_status, debug_mode)
            VALUES (7, 'Guests', 0, 0, 0), (9, 'Enabled debug mode', 0, 0, 1);
            
            INSERT IGNORE INTO users_groups (id, usrgrpid, userid) VALUES (1, 7, 1), (2, 9, 1);
          "
          
          echo "‚úÖ Database initialization completed successfully"
        fi

    - name: Deploy Zabbix Server Components
      run: |
        # Deploy Java Gateway first
        kubectl apply -f k8s/zabbix-additional.yaml
        kubectl wait --for=condition=available deployment/zabbix-java-gateway -n zabbix --timeout=300s
        
        # Deploy Zabbix Server
        kubectl apply -f k8s/zabbix-server.yaml
        kubectl wait --for=condition=available deployment/zabbix-server -n zabbix --timeout=300s

    - name: Deploy Zabbix Web Interface
      run: |
        kubectl apply -f k8s/zabbix-web.yaml
        kubectl wait --for=condition=available deployment/zabbix-web -n zabbix --timeout=300s

    - name: Deploy Ingress
      run: |
        kubectl apply -f k8s/zabbix-ingress.yaml
        
        # Wait for ingress to get an IP
        echo "Waiting for ingress to get external IP..."
        kubectl get ingress -n zabbix zabbix-ingress -w &
        sleep 60
        pkill kubectl

    - name: Get Application URLs
      run: |
        echo "=== Deployment Information ==="
        echo "Zabbix Web Interface URLs:"
        
        # Get LoadBalancer IP
        LB_IP=$(kubectl get service -n zabbix zabbix-web-external -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        if [ ! -z "$LB_IP" ]; then
          echo "LoadBalancer IP: http://$LB_IP"
        fi
        
        # Get Ingress information
        echo "Ingress Configuration:"
        kubectl get ingress -n zabbix zabbix-ingress
        
        echo ""
        echo "=== DNS Configuration Required ==="
        echo "Please configure your DNS to point dal2-devmon-mgt.forescout.com to the LoadBalancer IP"
        echo ""
        echo "=== Default Zabbix Credentials ==="
        echo "Username: Admin"
        echo "Password: zabbix"
        echo ""
        echo "=== Important Security Notes ==="
        echo "1. Change default Zabbix admin password immediately"
        echo "2. Update database passwords in production"
        echo "3. Configure SSL certificate for HTTPS"

    - name: Verify Deployment
      run: |
        echo "=== Verifying Zabbix Deployment ==="
        kubectl get all -n zabbix
        
        echo ""
        echo "=== Pod Status ==="
        kubectl get pods -n zabbix -o wide
        
        echo ""
        echo "=== Service Status ==="
        kubectl get services -n zabbix
        
        echo ""
        echo "=== Ingress Status ==="
        kubectl get ingress -n zabbix

  # Security and Post-Deployment
  post-deployment:
    needs: [deploy-infrastructure, deploy-zabbix, deploy-zabbix-only]
    runs-on: ubuntu-latest
    if: ${{ always() && (needs.deploy-zabbix.result == 'success' || needs.deploy-zabbix-only.result == 'success') && github.event.inputs.deployment_type != 'infrastructure-only' }}
    
    steps:
    - name: Azure CLI Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Configure Network Security
      run: |
        # Update NSG rules if needed
        echo "Configuring network security rules..."
        
        # Example: Restrict SSH access to specific IP ranges
        # az network nsg rule update \
        #   --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group }} \
        #   --nsg-name nsg-aks-* \
        #   --name AllowSSH \
        #   --source-address-prefixes "YOUR-OFFICE-IP/32"

    - name: Setup Monitoring and Alerts
      run: |
        echo "Setting up monitoring and alerts..."
        # Add any monitoring configuration here

    - name: Generate Deployment Report
      run: |
        echo "=== Deployment Summary Report ===" > deployment-report.md
        echo "**Date:** $(date)" >> deployment-report.md
        echo "**Environment:** Production" >> deployment-report.md
        echo "**AKS Cluster:** ${{ needs.deploy-infrastructure.outputs.aks-cluster-name }}" >> deployment-report.md
        echo "**Resource Group:** ${{ needs.deploy-infrastructure.outputs.resource-group }}" >> deployment-report.md
        echo "**Container Registry:** ${{ needs.deploy-infrastructure.outputs.container-registry }}" >> deployment-report.md
        echo "" >> deployment-report.md
        echo "**Next Steps:**" >> deployment-report.md
        echo "1. Configure DNS for dal2-devmon-mgt.forescout.com" >> deployment-report.md
        echo "2. Upload SSL certificate" >> deployment-report.md
        echo "3. Change default passwords" >> deployment-report.md
        echo "4. Configure Zabbix monitoring templates" >> deployment-report.md
        
        cat deployment-report.md

    - name: Upload Deployment Report
      uses: actions/upload-artifact@v3
      with:
        name: deployment-report
        path: deployment-report.md

  # Application-Only Deployment (uses existing AKS cluster)
  deploy-zabbix-only:
    runs-on: ubuntu-latest
    environment: production
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.deployment_type == 'application-only' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Display Application-Only Deployment Configuration
      run: |
        echo "=== Application-Only Deployment ==="
        echo "This deployment assumes AKS cluster already exists"
        echo "Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
        echo "Reset Database: ${{ github.event.inputs.reset_database || 'false' }}"
        echo "Debug Mode: ${{ github.event.inputs.debug_mode || 'false' }}"

    - name: Azure CLI Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Find and Connect to Existing AKS Cluster
      run: |
        echo "üîç Finding existing AKS cluster in resource group ${{ env.AZURE_RESOURCE_GROUP }}..."
        
        # List AKS clusters in the resource group
        AKS_CLUSTERS=$(az aks list --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "[].name" -o tsv)
        
        if [ -z "$AKS_CLUSTERS" ]; then
          echo "‚ùå No AKS clusters found in resource group ${{ env.AZURE_RESOURCE_GROUP }}"
          exit 1
        fi
        
        # Get the first (or only) cluster
        AKS_CLUSTER_NAME=$(echo "$AKS_CLUSTERS" | head -n 1)
        echo "‚úÖ Found AKS cluster: $AKS_CLUSTER_NAME"
        
        # Get credentials
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name "$AKS_CLUSTER_NAME" \
          --overwrite-existing
        
        # Verify connection
        kubectl cluster-info
        kubectl get nodes
        
        # Store cluster name for other steps
        echo "AKS_CLUSTER_NAME=$AKS_CLUSTER_NAME" >> $GITHUB_ENV

    - name: Deploy Zabbix (Application Only)
      run: |
        echo "üöÄ Deploying Zabbix application to existing cluster..."
        
        # Install NGINX Ingress Controller if not present
        if ! kubectl get namespace ingress-nginx >/dev/null 2>&1; then
          echo "Installing NGINX Ingress Controller..."
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx \
            --create-namespace \
            --set controller.replicaCount=2 \
            --set controller.service.type=LoadBalancer \
            --wait
        else
          echo "‚úÖ NGINX Ingress Controller already exists"
        fi
        
        # Deploy Zabbix namespace and configuration
        kubectl apply -f k8s/zabbix-config.yaml
        
        # Conditional cleanup based on user input
        if [ "${{ github.event.inputs.reset_database }}" = "true" ]; then
          echo "‚ö†Ô∏è Resetting all Zabbix resources and data..."
          kubectl delete all,pvc,configmap,secret -n zabbix --all --ignore-not-found=true
        else
          echo "üîÑ Performing smart cleanup (preserving data)..."
          kubectl delete deployment,service,ingress -n zabbix --ignore-not-found=true
        fi
        
        # Deploy MySQL
        kubectl apply -f k8s/zabbix-mysql.yaml
        kubectl wait --for=condition=ready pod -l app=zabbix-mysql -n zabbix --timeout=600s
        
        # Initialize database (with smart detection)
        # ... (reuse the database initialization logic from the main job)
        MYSQL_POD=$(kubectl get pods -n zabbix -l app=zabbix-mysql -o jsonpath='{.items[0].metadata.name}')
        DB_EXISTS=$(kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='zabbix';" 2>/dev/null | tail -n 1 || echo "0")
        
        if [ "${{ github.event.inputs.reset_database }}" = "true" ]; then
          DB_EXISTS="0"
        fi
        
        if [ "$DB_EXISTS" -lt "10" ]; then
          echo "üîß Initializing Zabbix database..."
          kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "DROP DATABASE IF EXISTS zabbix;"
          kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "CREATE DATABASE zabbix CHARACTER SET utf8 COLLATE utf8_bin;"
          kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "GRANT ALL PRIVILEGES ON zabbix.* TO 'zabbix'@'%' IDENTIFIED BY 'zabbix123!';"
          kubectl apply -f k8s/zabbix-db-init-direct.yaml
          kubectl wait --for=condition=complete job/zabbix-db-init -n zabbix --timeout=600s || true
        fi
        
        # Deploy Zabbix components
        kubectl apply -f k8s/zabbix-additional.yaml
        kubectl wait --for=condition=available deployment/zabbix-java-gateway -n zabbix --timeout=300s
        
        kubectl apply -f k8s/zabbix-server.yaml
        kubectl wait --for=condition=available deployment/zabbix-server -n zabbix --timeout=300s
        
        kubectl apply -f k8s/zabbix-web.yaml
        kubectl wait --for=condition=available deployment/zabbix-web -n zabbix --timeout=300s
        
        kubectl apply -f k8s/zabbix-ingress.yaml
        
        echo "‚úÖ Application-only deployment completed!"
        
        # Display status
        kubectl get all -n zabbix
        kubectl get ingress -n zabbix

  # PowerShell-Only Deployment (Alternative for Azure CLI issues)
  deploy-infrastructure-powershell:
    runs-on: windows-latest
    environment: production
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.force_powershell == 'true' }}
    outputs:
      aks-cluster-name: ${{ steps.deploy-pwsh-only.outputs.AKS_CLUSTER_NAME }}
      resource-group: ${{ steps.deploy-pwsh-only.outputs.AZURE_RESOURCE_GROUP }}
      container-registry: ${{ steps.deploy-pwsh-only.outputs.CONTAINER_REGISTRY_ENDPOINT }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: PowerShell-Only Azure Infrastructure Deployment
      id: deploy-pwsh-only
      shell: pwsh
      run: |
        Write-Host "üöÄ Starting PowerShell-only deployment (Azure CLI alternative)..." -ForegroundColor Cyan
        
        try {
          # Install Azure PowerShell modules
          Write-Host "üì¶ Installing Azure PowerShell modules..." -ForegroundColor Yellow
          Install-Module -Name Az -Force -AllowClobber -Scope CurrentUser -Repository PSGallery
          
          # Import required modules
          Import-Module Az.Accounts -Force
          Import-Module Az.Resources -Force
          
          # Parse credentials and authenticate
          $creds = '${{ secrets.AZURE_CREDENTIALS }}' | ConvertFrom-Json
          $securePassword = ConvertTo-SecureString $creds.clientSecret -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential($creds.clientId, $securePassword)
          
          # Authenticate with Azure PowerShell
          Write-Host "üîê Authenticating with Azure PowerShell..." -ForegroundColor Blue
          $context = Connect-AzAccount -ServicePrincipal -Credential $credential -Tenant $creds.tenantId -Subscription "${{ env.AZURE_SUBSCRIPTION_ID }}"
          Write-Host "‚úÖ Authentication successful to: $($context.Context.Subscription.Name)" -ForegroundColor Green
          
          # Verify resource group access
          $resourceGroup = Get-AzResourceGroup -Name "${{ env.AZURE_RESOURCE_GROUP }}" -ErrorAction SilentlyContinue
          if (-not $resourceGroup) {
            throw "Cannot access resource group '${{ env.AZURE_RESOURCE_GROUP }}'"
          }
          Write-Host "‚úÖ Resource group access confirmed" -ForegroundColor Green
          
          # Deploy using PowerShell script
          $scriptPath = Join-Path $env:GITHUB_WORKSPACE "scripts" "deploy-infrastructure-pwsh.ps1"
          
          if (Test-Path $scriptPath) {
            Write-Host "üöÄ Executing PowerShell deployment script..." -ForegroundColor Cyan
            
            # Generate environment name with DevOps naming convention
            $envSuffix = "${{ github.event.inputs.environment_suffix }}"
            if ([string]::IsNullOrEmpty($envSuffix)) {
              $deploymentEnvName = "zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}"
            } else {
              $deploymentEnvName = "zabbix-devops-${{ env.AZURE_LOCATION }}-${{ github.run_number }}-$envSuffix"
            }
            Write-Host "Deployment environment name: $deploymentEnvName" -ForegroundColor Yellow
            Write-Host "Resources will be named with pattern: resourcename-devops-${{ env.AZURE_LOCATION }}" -ForegroundColor Yellow
            
            & $scriptPath -ResourceGroupName "${{ env.AZURE_RESOURCE_GROUP }}" -Location "${{ env.AZURE_LOCATION }}" -EnvironmentName $deploymentEnvName -SubscriptionId "${{ env.AZURE_SUBSCRIPTION_ID }}"
            
            if ($LASTEXITCODE -eq 0) {
              Write-Host "‚úÖ PowerShell-only deployment completed successfully!" -ForegroundColor Green
            } else {
              throw "PowerShell deployment script failed with exit code $LASTEXITCODE"
            }
          } else {
            throw "PowerShell deployment script not found at: $scriptPath"
          }
          
        } catch {
          Write-Host "‚ùå PowerShell deployment failed: $($_.Exception.Message)" -ForegroundColor Red
          exit 1
        }

  # Final Deployment Summary
  deployment-summary:
    needs: [deploy-infrastructure, deploy-zabbix, deploy-zabbix-only, deploy-infrastructure-powershell, post-deployment]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Generate Final Deployment Summary
      run: |
        echo "=== Final Deployment Summary ===" >> $GITHUB_STEP_SUMMARY
        echo "**Deployment Configuration:**" >> $GITHUB_STEP_SUMMARY
        echo "- Type: ${{ github.event.inputs.deployment_type || 'full' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Force PowerShell: ${{ github.event.inputs.force_powershell || 'false' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Reset Database: ${{ github.event.inputs.reset_database || 'false' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Debug Mode: ${{ github.event.inputs.debug_mode || 'false' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Environment Suffix: ${{ github.event.inputs.environment_suffix || 'none' }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "**Job Results:**" >> $GITHUB_STEP_SUMMARY
        echo "- Infrastructure: ${{ needs.deploy-infrastructure.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Zabbix Application: ${{ needs.deploy-zabbix.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Application-Only: ${{ needs.deploy-zabbix-only.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
        echo "- PowerShell Deployment: ${{ needs.deploy-infrastructure-powershell.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Post-Deployment: ${{ needs.post-deployment.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Determine overall success
        if [[ "${{ needs.deploy-zabbix.result }}" == "success" || "${{ needs.deploy-zabbix-only.result }}" == "success" ]]; then
          echo "**‚úÖ Overall Status: SUCCESS**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Configure DNS for dal2-devmon-mgt.forescout.com" >> $GITHUB_STEP_SUMMARY
          echo "2. Upload SSL certificate" >> $GITHUB_STEP_SUMMARY
          echo "3. Change default Zabbix admin password (Admin/zabbix)" >> $GITHUB_STEP_SUMMARY
          echo "4. Configure monitoring templates" >> $GITHUB_STEP_SUMMARY
        elif [[ "${{ needs.deploy-infrastructure.result }}" == "success" && "${{ github.event.inputs.deployment_type }}" == "infrastructure-only" ]]; then
          echo "**‚úÖ Infrastructure Deployment: SUCCESS**" >> $GITHUB_STEP_SUMMARY
          echo "Infrastructure is ready for application deployment." >> $GITHUB_STEP_SUMMARY
        else
          echo "**‚ùå Overall Status: FAILED**" >> $GITHUB_STEP_SUMMARY
          echo "Check individual job logs for details." >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Redeployment Options:**" >> $GITHUB_STEP_SUMMARY
        echo "- **Full Redeploy**: Use 'redeploy-clean' deployment type" >> $GITHUB_STEP_SUMMARY
        echo "- **App Only**: Use 'application-only' to redeploy just Zabbix" >> $GITHUB_STEP_SUMMARY
        echo "- **Infrastructure Only**: Use 'infrastructure-only' for infra changes" >> $GITHUB_STEP_SUMMARY
        echo "- **Reset Database**: Enable 'reset_database' option (‚ö†Ô∏è destroys data)" >> $GITHUB_STEP_SUMMARY
