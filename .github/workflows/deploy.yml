name: Deploy AKS Zabbix Infrastructure (Terraform & ARM)

on:
  # Only run on manual trigger or when infrastructure files change
  push:
    branches: [ main, develop ]
    paths:
      - 'infra/**'
      - 'k8s/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'infra/**'
      - 'k8s/**'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      deployment_type:
        description: 'Type of deployment'
        required: true
        default: 'application-only'
        type: choice
        options:
        - full
        - infrastructure-only
        - application-only
        - redeploy-clean
      infrastructure_method:
        description: 'Infrastructure deployment method'
        required: true
        default: 'terraform'
        type: choice
        options:
        - terraform
        - arm
        - both
      terraform_mode:
        description: 'Terraform execution mode'
        required: false
        default: 'plan-and-apply'
        type: choice
        options:
        - plan-only
        - plan-and-apply
        - apply-existing-plan
      force_powershell:
        description: 'Force PowerShell deployment (skip Azure CLI)'
        required: false
        default: false
        type: boolean
      reset_database:
        description: 'Reset Zabbix database (WARNING: destroys data)'
        required: false
        default: false
        type: boolean
      environment_suffix:
        description: 'Environment suffix (optional)'
        required: false
        default: ''
        type: string
      debug_mode:
        description: 'Enable debug logging'
        required: false
        default: false
        type: boolean

env:
  AZURE_RESOURCE_GROUP: 'rg-devops-pops-eastus'
  AZURE_LOCATION: 'eastus'
  AZURE_SUBSCRIPTION_ID: 'd9b2a1cf-f99b-4f9e-a6cf-c79a078406bf'
  AKS_CLUSTER_NAME: 'aks-devops-eastus'
  CONTAINER_REGISTRY_NAME: 'acrdevopseastus'
  DEPLOYMENT_TYPE: ${{ github.event.inputs.deployment_type || (github.event_name == 'push' && 'full') || 'application-only' }}
  INFRASTRUCTURE_METHOD: ${{ github.event.inputs.infrastructure_method || 'terraform' }}
  TERRAFORM_MODE: ${{ github.event.inputs.terraform_mode || 'plan-and-apply' }}
  FORCE_POWERSHELL: ${{ github.event.inputs.force_powershell || 'false' }}
  RESET_DATABASE: ${{ github.event.inputs.reset_database || 'false' }}
  DEBUG_MODE: ${{ github.event.inputs.debug_mode || 'false' }}
  ENV_SUFFIX: ${{ github.event.inputs.environment_suffix || '' }}

jobs:
  # Infrastructure Deployment
  deploy-infrastructure:
    runs-on: ubuntu-latest
    environment: production
    if: ${{ github.event.inputs.deployment_type == 'full' || github.event.inputs.deployment_type == 'infrastructure-only' || github.event.inputs.deployment_type == 'redeploy-clean' || github.event_name == 'push' || github.event_name == 'pull_request' }}
    outputs:
      aks-cluster-name: ${{ steps.deploy-infra.outputs.AKS_CLUSTER_NAME }}
      resource-group: ${{ steps.deploy-infra.outputs.AZURE_RESOURCE_GROUP }}
      container-registry: ${{ steps.deploy-infra.outputs.CONTAINER_REGISTRY_ENDPOINT }}
      deployment-success: ${{ steps.deploy-infra.outputs.DEPLOYMENT_SUCCESS }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Display Deployment Configuration
      run: |
        echo "=== Deployment Configuration ==="
        echo "Deployment Type: ${{ github.event.inputs.deployment_type || 'application-only' }}"
        echo "Infrastructure Method: ${{ github.event.inputs.infrastructure_method || 'terraform' }}"
        echo "Terraform Mode: ${{ github.event.inputs.terraform_mode || 'plan-and-apply' }}"
        echo "Force PowerShell: ${{ github.event.inputs.force_powershell || 'false' }}"
        echo "Reset Database: ${{ github.event.inputs.reset_database || 'false' }}"
        echo "Debug Mode: ${{ github.event.inputs.debug_mode || 'false' }}"
        echo "Environment Suffix: ${{ github.event.inputs.environment_suffix || 'none' }}"
        echo "Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
        echo "Location: ${{ env.AZURE_LOCATION }}"
        echo "Run Number: ${{ github.run_number }}"
        echo "Actor: ${{ github.actor }}"
        echo "Triggered by: ${{ github.event_name }}"
        
        if [ "${{ github.event.inputs.debug_mode }}" = "true" ]; then
          echo "DEBUG_MODE=true" >> $GITHUB_ENV
          echo "ðŸ› Debug mode enabled - detailed logging will be provided"
        fi

    - name: Azure CLI Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set up Azure CLI
      run: |
        az account set --subscription ${{ env.AZURE_SUBSCRIPTION_ID }}
        az account show

    - name: Install Terraform
      run: |
        echo "ðŸ”§ Installing Terraform..."
        
        # Download and install Terraform
        TERRAFORM_VERSION="1.6.0"
        curl -Lo terraform.zip "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip"
        unzip terraform.zip
        sudo mv terraform /usr/local/bin/
        rm terraform.zip
        
        # Verify installation
        terraform version
        echo "âœ… Terraform installed successfully"

    - name: Validate Infrastructure Method Selection
      run: |
        echo "ðŸ” Validating infrastructure deployment method..."
        echo "Selected method: ${{ env.INFRASTRUCTURE_METHOD }}"
        echo "Terraform mode: ${{ env.TERRAFORM_MODE }}"
        
        case "${{ env.INFRASTRUCTURE_METHOD }}" in
          "terraform")
            echo "âœ… Will use Terraform for infrastructure deployment"
            echo "DEPLOY_TERRAFORM=true" >> $GITHUB_ENV
            echo "DEPLOY_ARM=false" >> $GITHUB_ENV
            ;;
          "arm")
            echo "âœ… Will use ARM templates for infrastructure deployment"
            echo "DEPLOY_TERRAFORM=false" >> $GITHUB_ENV
            echo "DEPLOY_ARM=true" >> $GITHUB_ENV
            ;;
          "both")
            echo "âœ… Will try Terraform first, then ARM as fallback"
            echo "DEPLOY_TERRAFORM=true" >> $GITHUB_ENV
            echo "DEPLOY_ARM=true" >> $GITHUB_ENV
            ;;
          *)
            echo "âŒ Invalid infrastructure method: ${{ env.INFRASTRUCTURE_METHOD }}"
            exit 1
            ;;
        esac
        
        # Set Terraform execution mode
        case "${{ env.TERRAFORM_MODE }}" in
          "plan-only")
            echo "ðŸ“‹ Will only create Terraform plan for review"
            echo "TF_PLAN_ONLY=true" >> $GITHUB_ENV
            echo "TF_APPLY_EXISTING=false" >> $GITHUB_ENV
            ;;
          "apply-existing-plan")
            echo "ðŸš€ Will apply existing Terraform plan"
            echo "TF_PLAN_ONLY=false" >> $GITHUB_ENV
            echo "TF_APPLY_EXISTING=true" >> $GITHUB_ENV
            ;;
          "plan-and-apply")
            echo "ðŸ“‹ðŸš€ Will create plan and apply immediately"
            echo "TF_PLAN_ONLY=false" >> $GITHUB_ENV
            echo "TF_APPLY_EXISTING=false" >> $GITHUB_ENV
            ;;
          *)
            echo "âŒ Invalid terraform mode: ${{ env.TERRAFORM_MODE }}"
            exit 1
            ;;
        esac

    - name: Prepare Terraform Environment
      if: ${{ env.INFRASTRUCTURE_METHOD == 'terraform' || env.INFRASTRUCTURE_METHOD == 'both' }}
      run: |
        echo "ðŸ”§ Preparing Terraform environment..."
        
        # Navigate to Terraform directory
        cd infra/terraform
        
        # Generate consistent environment name (without run number to avoid resource conflicts)
        ENV_SUFFIX="${{ github.event.inputs.environment_suffix }}"
        if [ -n "$ENV_SUFFIX" ]; then
          ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-$ENV_SUFFIX"
        else
          ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}"
        fi
        echo "Environment name: $ENV_NAME"
        echo "This will create resources with naming pattern: resourcename-devops-${{ env.AZURE_LOCATION }}"
        
        # Create terraform.tfvars file
        cat > terraform.tfvars << EOF
        resource_group_name = "${{ env.AZURE_RESOURCE_GROUP }}"
        location           = "${{ env.AZURE_LOCATION }}"
        environment_name   = "$ENV_NAME"
        
        # AKS Configuration
        kubernetes_version = "1.32"
        
        # Node Pool Configuration
        aks_system_node_count = 2
        aks_user_node_count   = 3
        aks_user_node_min_count = 2
        aks_user_node_max_count = 10
        
        # VM Sizes
        aks_system_vm_size = "Standard_D2s_v3"
        aks_user_vm_size   = "Standard_D4s_v3"
        
        # Feature Flags
        enable_auto_scaling  = true
        enable_azure_policy  = true
        enable_log_analytics = true
        
        # Monitoring
        log_analytics_retention_days = 30
        EOF
        
        echo "âœ… Terraform environment prepared"
        
        # Store environment name for later steps
        echo "TERRAFORM_ENV_NAME=$ENV_NAME" >> $GITHUB_ENV

    - name: Initialize Terraform
      if: ${{ env.INFRASTRUCTURE_METHOD == 'terraform' || env.INFRASTRUCTURE_METHOD == 'both' }}
      run: |
        cd infra/terraform
        
        echo "ðŸš€ Starting Terraform deployment process..."
        echo "Mode: ${{ env.TERRAFORM_MODE }}"
        
        # Initialize Terraform
        echo "ðŸ“¦ Initializing Terraform..."
        terraform init

    - name: Set Script Permissions
      if: ${{ env.INFRASTRUCTURE_METHOD == 'terraform' || env.INFRASTRUCTURE_METHOD == 'both' }}
      run: |
        # Make all Terraform helper scripts executable
        chmod +x scripts/terraform/*.sh
        echo "âœ… Script permissions set"

    - name: Deploy Infrastructure with Terraform
      id: terraform-deploy
      if: ${{ env.INFRASTRUCTURE_METHOD == 'terraform' || env.INFRASTRUCTURE_METHOD == 'both' }}
      run: |
        cd infra/terraform
        
        # Run the master deployment script that orchestrates everything
        ../../scripts/terraform/terraform-master.sh "${{ env.TERRAFORM_MODE }}" "${{ github.event.inputs.debug_mode }}"

    - name: Cleanup Kubernetes Provider (Always Run)
      if: always() && (env.INFRASTRUCTURE_METHOD == 'terraform' || env.INFRASTRUCTURE_METHOD == 'both')
      run: |
        cd infra/terraform
        ../../scripts/terraform/terraform-provider-helper.sh cleanup

    - name: Upload Terraform Plan Artifacts
      if: ${{ env.INFRASTRUCTURE_METHOD == 'terraform' || env.INFRASTRUCTURE_METHOD == 'both' }}
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan-${{ github.run_number }}
        path: |
          infra/terraform/terraform-plan.json
          infra/terraform/terraform-plan.txt
          infra/terraform/tfplan-*
        retention-days: 7

    - name: Pre-deployment Diagnostics
      if: ${{ steps.terraform-deploy.outputs.DEPLOYMENT_SUCCESS != 'true' && env.INFRASTRUCTURE_METHOD == 'arm' }}
      run: |
        echo "ðŸ” Running pre-deployment diagnostics for ARM template fallback..."
        
        # Check resource group access
        echo "Checking resource group access..."
        az group show --name ${{ env.AZURE_RESOURCE_GROUP }} --output table || {
          echo "âŒ Cannot access resource group ${{ env.AZURE_RESOURCE_GROUP }}"
          exit 1
        }
        
        # Check resource providers
        echo "Checking required resource providers..."
        REQUIRED_PROVIDERS="Microsoft.ContainerService Microsoft.Network Microsoft.ContainerRegistry Microsoft.ManagedIdentity Microsoft.OperationalInsights"
        for provider in $REQUIRED_PROVIDERS; do
          STATUS=$(az provider show --namespace $provider --query registrationState -o tsv)
          echo "  $provider: $STATUS"
          if [ "$STATUS" != "Registered" ]; then
            echo "âš ï¸ Registering provider $provider..."
            az provider register --namespace $provider --wait
          fi
        done
        
        echo "âœ… Pre-deployment diagnostics completed"

    - name: Validate Terraform Configuration (if using Terraform)
      if: ${{ env.INFRASTRUCTURE_METHOD == 'terraform' || env.INFRASTRUCTURE_METHOD == 'both' }}
      run: |
        echo "ðŸ” Validating Terraform configuration..."
        cd infra/terraform
        
        # Validate syntax
        if ! terraform validate; then
          echo "âŒ Terraform validation failed"
          exit 1
        fi
        echo "âœ… Terraform configuration is valid"

    - name: Deploy Infrastructure with ARM Template (Fallback)
      id: deploy-infra-arm
      if: ${{ env.INFRASTRUCTURE_METHOD == 'arm' || (env.INFRASTRUCTURE_METHOD == 'both' && steps.terraform-deploy.outputs.DEPLOYMENT_SUCCESS != 'true') }}
      run: |
        echo "ðŸš€ Deploying infrastructure using ARM template..."
        
        # Generate deployment name with timestamp
        TIMESTAMP=$(date +%s)
        ARM_DEPLOYMENT_NAME="zabbix-arm-deploy-${{ github.run_number }}-$TIMESTAMP"
        echo "ARM Deployment name: $ARM_DEPLOYMENT_NAME"
        
        # Generate environment name with DevOps naming convention (consistent with Terraform)
        ENV_SUFFIX="${{ github.event.inputs.environment_suffix }}"
        if [ -n "$ENV_SUFFIX" ]; then
          DEPLOYMENT_ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}-$ENV_SUFFIX"
        else
          DEPLOYMENT_ENV_NAME="zabbix-devops-${{ env.AZURE_LOCATION }}"
        fi
        
        echo "Deployment environment name: $DEPLOYMENT_ENV_NAME"
        echo "Resources will be named with pattern: resourcename-devops-${{ env.AZURE_LOCATION }}"
        
        # Deploy ARM template
        set +e  # Don't exit on error
        ARM_DEPLOYMENT_OUTPUT=$(timeout 1800 az deployment group create \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --template-file infra/main-arm.json \
          --parameters environmentName="$DEPLOYMENT_ENV_NAME" \
                       location="${{ env.AZURE_LOCATION }}" \
          --name "$ARM_DEPLOYMENT_NAME" \
          --mode Incremental \
          --output json \
          --only-show-errors 2>&1)
        ARM_DEPLOYMENT_EXIT_CODE=$?
        set -e  # Re-enable exit on error
        
        if [ $ARM_DEPLOYMENT_EXIT_CODE -ne 0 ]; then
          echo "âŒ ARM template deployment failed with exit code $ARM_DEPLOYMENT_EXIT_CODE"
          echo "Error output:"
          echo "$ARM_DEPLOYMENT_OUTPUT"
          echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_OUTPUT
        else
          echo "âœ… ARM template deployment successful!"
          
          # Extract outputs
          AKS_CLUSTER_NAME=$(echo "$ARM_DEPLOYMENT_OUTPUT" | jq -r '.properties.outputs.AKS_CLUSTER_NAME.value // empty')
          CONTAINER_REGISTRY_ENDPOINT=$(echo "$ARM_DEPLOYMENT_OUTPUT" | jq -r '.properties.outputs.CONTAINER_REGISTRY_ENDPOINT.value // empty')
          
          if [ -z "$AKS_CLUSTER_NAME" ] || [ "$AKS_CLUSTER_NAME" = "null" ]; then
            echo "âŒ Failed to get AKS cluster name from ARM deployment outputs"
            echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_OUTPUT
          else
            # Set outputs
            echo "AKS_CLUSTER_NAME=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
            echo "AZURE_RESOURCE_GROUP=${{ env.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
            echo "CONTAINER_REGISTRY_ENDPOINT=$CONTAINER_REGISTRY_ENDPOINT" >> $GITHUB_OUTPUT
            echo "DEPLOYMENT_METHOD=arm" >> $GITHUB_OUTPUT
            echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
            
            echo "âœ… ARM Infrastructure deployed successfully!"
            echo "   AKS Cluster: $AKS_CLUSTER_NAME"
            echo "   Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
            echo "   Container Registry: $CONTAINER_REGISTRY_ENDPOINT"
          fi
        fi

    - name: Set Infrastructure Outputs
      id: deploy-infra
      run: |
        # Handle different deployment modes and methods
        TF_STATUS="${{ steps.terraform-deploy.outputs.DEPLOYMENT_SUCCESS }}"
        ARM_STATUS="${{ steps.deploy-infra-arm.outputs.DEPLOYMENT_SUCCESS }}"
        
        echo "Terraform status: $TF_STATUS"
        echo "ARM status: $ARM_STATUS"
        echo "Terraform mode: ${{ env.TERRAFORM_MODE }}"
        
        # Handle Terraform results
        if [ "$TF_STATUS" = "true" ]; then
          echo "âœ… Using Terraform deployment outputs (full deployment)"
          echo "AKS_CLUSTER_NAME=${{ steps.terraform-deploy.outputs.AKS_CLUSTER_NAME }}" >> $GITHUB_OUTPUT
          echo "AZURE_RESOURCE_GROUP=${{ steps.terraform-deploy.outputs.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
          echo "CONTAINER_REGISTRY_ENDPOINT=${{ steps.terraform-deploy.outputs.CONTAINER_REGISTRY_ENDPOINT }}" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
          echo "âœ… Used Terraform for full deployment" >> $GITHUB_STEP_SUMMARY
        elif [ "$TF_STATUS" = "plan-created" ]; then
          echo "ðŸ“‹ Terraform plan created successfully (plan-only mode)"
          echo "AKS_CLUSTER_NAME=${{ steps.terraform-deploy.outputs.AKS_CLUSTER_NAME }}" >> $GITHUB_OUTPUT
          echo "AZURE_RESOURCE_GROUP=${{ steps.terraform-deploy.outputs.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
          echo "CONTAINER_REGISTRY_ENDPOINT=${{ steps.terraform-deploy.outputs.CONTAINER_REGISTRY_ENDPOINT }}" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_SUCCESS=plan-created" >> $GITHUB_OUTPUT
          echo "ðŸ“‹ Terraform plan created and saved for later apply" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ’¡ Run with 'apply-existing-plan' mode to deploy the planned infrastructure" >> $GITHUB_STEP_SUMMARY
        elif [ "$ARM_STATUS" = "true" ]; then
          echo "âœ… Using ARM template deployment outputs"
          echo "AKS_CLUSTER_NAME=${{ steps.deploy-infra-arm.outputs.AKS_CLUSTER_NAME }}" >> $GITHUB_OUTPUT
          echo "AZURE_RESOURCE_GROUP=${{ steps.deploy-infra-arm.outputs.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
          echo "CONTAINER_REGISTRY_ENDPOINT=${{ steps.deploy-infra-arm.outputs.CONTAINER_REGISTRY_ENDPOINT }}" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
          echo "âœ… Used ARM template for deployment" >> $GITHUB_STEP_SUMMARY
        else
          echo "âŒ All deployment methods failed or returned empty outputs" >> $GITHUB_STEP_SUMMARY
          echo "Terraform status: $TF_STATUS"
          echo "ARM status: $ARM_STATUS"
          echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: Display Deployment Summary
      run: |
        echo ""
        echo "=== Final Deployment Results ==="
        if [ "${{ steps.terraform-deploy.outputs.DEPLOYMENT_SUCCESS }}" = "true" ]; then
          echo "âœ… Deployment Method: Terraform"
          echo "AKS Cluster Name: ${{ steps.terraform-deploy.outputs.AKS_CLUSTER_NAME }}"
          echo "Resource Group: ${{ steps.terraform-deploy.outputs.AZURE_RESOURCE_GROUP }}"
          echo "Container Registry: ${{ steps.terraform-deploy.outputs.CONTAINER_REGISTRY_ENDPOINT }}"
        elif [ "${{ steps.terraform-deploy.outputs.DEPLOYMENT_SUCCESS }}" = "plan-created" ]; then
          echo "ðŸ“‹ Deployment Method: Terraform (Plan-Only Mode)"
          echo "Plan Status: Created and saved for later apply"
          echo "AKS Cluster Name: ${{ steps.terraform-deploy.outputs.AKS_CLUSTER_NAME }}"
          echo "Resource Group: ${{ steps.terraform-deploy.outputs.AZURE_RESOURCE_GROUP }}"
          echo "Container Registry: ${{ steps.terraform-deploy.outputs.CONTAINER_REGISTRY_ENDPOINT }}"
        elif [ "${{ steps.deploy-infra-arm.outputs.DEPLOYMENT_SUCCESS }}" = "true" ]; then
          echo "âœ… Deployment Method: ARM Template"
          echo "AKS Cluster Name: ${{ steps.deploy-infra-arm.outputs.AKS_CLUSTER_NAME }}"
          echo "Resource Group: ${{ steps.deploy-infra-arm.outputs.AZURE_RESOURCE_GROUP }}"
          echo "Container Registry: ${{ steps.deploy-infra-arm.outputs.CONTAINER_REGISTRY_ENDPOINT }}"
        else
          echo "âŒ No successful deployment to display"
        fi

    - name: Get AKS credentials
      if: steps.deploy-infra.outputs.DEPLOYMENT_SUCCESS == 'true'
      run: |
        echo "ðŸ”‘ Getting AKS credentials..."
        echo "Cluster: ${{ env.AKS_CLUSTER_NAME }}"
        echo "Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
        
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER_NAME }} \
          --overwrite-existing

    - name: Verify AKS connection
      if: steps.deploy-infra.outputs.DEPLOYMENT_SUCCESS == 'true'
      run: |
        echo "ðŸ” Verifying AKS cluster connection..."
        kubectl cluster-info
        kubectl get nodes
        kubectl get namespaces

  # Deploy Zabbix Application
  deploy-zabbix:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    environment: production
    if: ${{ always() && (github.event.inputs.deployment_type == 'full' || github.event.inputs.deployment_type == 'application-only' || github.event.inputs.deployment_type == 'redeploy-clean' || github.event_name == 'push' || github.event_name == 'pull_request') && (needs.deploy-infrastructure.result == 'success' || github.event.inputs.deployment_type == 'application-only') && (needs.deploy-infrastructure.outputs.deployment-success == 'true' || github.event.inputs.deployment_type == 'application-only') }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure CLI Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Install and Setup kubectl
      run: |
        echo "ðŸ”§ Setting up kubectl and Helm..."
        
        # Install kubectl if not available
        if ! command -v kubectl &> /dev/null; then
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
        fi
        
        # Install Helm if not available
        if ! command -v helm &> /dev/null; then
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
        fi
        
        echo "âœ… kubectl and Helm are ready"

    - name: Get AKS credentials
      run: |
        echo "ðŸ”‘ Getting AKS credentials for application deployment..."
        echo "Cluster: ${{ env.AKS_CLUSTER_NAME }}"
        echo "Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
        
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER_NAME }} \
          --overwrite-existing
        
        # Verify connection
        kubectl cluster-info
        kubectl get nodes
        echo "âœ… AKS connection verified"

    - name: Install Application Gateway Ingress Controller
      run: |
        echo "ðŸš€ Installing Application Gateway Ingress Controller (AGIC)..."
        
        # Get Application Gateway name from Terraform outputs or use default
        if [ -f "infra/terraform/terraform.tfstate" ]; then
          APPGW_NAME=$(cd infra/terraform && terraform output -raw APPLICATION_GATEWAY_NAME 2>/dev/null || echo "")
        fi
        
        if [ -z "$APPGW_NAME" ]; then
          APPGW_NAME="appgw-devops-eastus"
          echo "âš ï¸ Could not retrieve APPGW name from Terraform, using default: $APPGW_NAME"
        else
          echo "âœ… Retrieved Application Gateway name from Terraform: $APPGW_NAME"
        fi
        
        # Check if AGIC addon is already enabled
        AGIC_STATUS=$(az aks addon show \
          --name ${{ env.AKS_CLUSTER_NAME }} \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --addon ingress-appgw \
          --query "enabled" \
          -o tsv 2>/dev/null || echo "false")
        
        if [ "$AGIC_STATUS" = "true" ]; then
          echo "âœ… AGIC addon is already enabled on the AKS cluster"
        else
          echo "ðŸ“¦ Installing AGIC using AKS addon (modern approach)..."
          
          # Enable AGIC addon on AKS cluster
          az aks addon enable \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --addon ingress-appgw \
            --appgw-name $APPGW_NAME || {
            echo "âš ï¸ AGIC addon installation failed, attempting manual configuration..."
            
            # Try to install AGIC using Azure CLI with existing App Gateway
            echo "ðŸ”§ Attempting to use existing Application Gateway..."
            APPGW_ID="/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RESOURCE_GROUP }}/providers/Microsoft.Network/applicationGateways/$APPGW_NAME"
            
            az aks addon enable \
              --name ${{ env.AKS_CLUSTER_NAME }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --addon ingress-appgw \
              --appgw-id "$APPGW_ID" || {
              echo "âš ï¸ All AGIC methods failed, falling back to NGINX Ingress..."
              
              # Check if NGINX Ingress is already installed
              if helm list -n ingress-nginx | grep -q "ingress-nginx"; then
                echo "âœ… NGINX Ingress is already installed"
              else
                echo "ðŸ“¦ Installing NGINX Ingress Controller..."
                # Fallback to NGINX Ingress Controller
                helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
                helm repo update
                
                helm install ingress-nginx ingress-nginx/ingress-nginx \
                  --namespace ingress-nginx \
                  --create-namespace \
                  --set controller.replicaCount=2 \
                  --set controller.service.type=LoadBalancer \
                  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz \
                  --wait
              fi
            }
          }
        fi
        
        # Verify AGIC installation
        echo "ðŸ” Verifying ingress controller installation..."
        kubectl get pods -n kube-system -l app=ingress-appgw || {
          echo "AGIC not found in kube-system, checking other namespaces..."
          kubectl get pods --all-namespaces | grep -E "(ingress|agic)" || echo "No ingress controllers found"
        }
        
        echo "âœ… Ingress controller installation completed"

    - name: Deploy Zabbix Namespace and Configuration
      run: |
        kubectl apply -f applications/zabbix/k8s/zabbix-config.yaml
        kubectl get namespace zabbix

    - name: Cleanup Existing Zabbix Resources (Conditional)
      if: ${{ github.event.inputs.deployment_type == 'redeploy-clean' || github.event.inputs.reset_database == 'true' }}
      run: |
        echo "ðŸ§¹ Cleaning up existing Zabbix resources for fresh deployment..."
        echo "Deployment Type: ${{ github.event.inputs.deployment_type }}"
        echo "Reset Database: ${{ github.event.inputs.reset_database }}"
        
        # Delete Zabbix deployments and services
        kubectl delete deployment --all -n zabbix --ignore-not-found=true
        kubectl delete service --all -n zabbix --ignore-not-found=true
        kubectl delete ingress --all -n zabbix --ignore-not-found=true
        kubectl delete configmap --all -n zabbix --ignore-not-found=true
        kubectl delete secret --all -n zabbix --ignore-not-found=true
        
        # Wait for pods to terminate
        kubectl wait --for=delete pods --all -n zabbix --timeout=120s || true
        
        # Clean up PVCs if database reset is requested
        if [ "${{ github.event.inputs.reset_database }}" = "true" ]; then
          echo "âš ï¸ RESETTING DATABASE - All data will be lost!"
          kubectl delete pvc -n zabbix --all --ignore-not-found=true
        fi
        
        echo "âœ… Cleanup completed"

    - name: Smart Cleanup for Regular Deployments
      if: ${{ github.event.inputs.deployment_type != 'redeploy-clean' && github.event.inputs.reset_database != 'true' }}
      run: |
        echo "ðŸ”„ Performing smart cleanup (preserving data)..."
        
        # Create namespace if it doesn't exist
        kubectl create namespace zabbix --dry-run=client -o yaml | kubectl apply -f -
        
        # Only delete deployments and services, keep PVCs and secrets
        kubectl delete deployment --all -n zabbix --ignore-not-found=true
        kubectl delete service --all -n zabbix --ignore-not-found=true
        kubectl delete ingress --all -n zabbix --ignore-not-found=true
        
        # Wait for pods to terminate (but not MySQL pods)
        kubectl wait --for=delete pods -l app!=zabbix-mysql -n zabbix --timeout=60s || echo "âš ï¸ Some pods may still be terminating"
        
        echo "âœ… Smart cleanup completed - data preserved"

    - name: Deploy MySQL Database
      run: |
        kubectl apply -f applications/zabbix/k8s/zabbix-mysql.yaml
        
        # Wait for MySQL to be ready
        kubectl wait --for=condition=ready pod -l app=zabbix-mysql -n zabbix --timeout=600s

    - name: Initialize Zabbix Database with Complete Setup
      run: |
        echo "ðŸ—„ï¸ Initializing Zabbix database with complete schema and users..."
        
        # Wait for MySQL pod to be running
        kubectl wait --for=condition=ready pod -l app=zabbix-mysql -n zabbix --timeout=300s
        
        # Get MySQL pod name
        MYSQL_POD=$(kubectl get pods -n zabbix -l app=zabbix-mysql -o jsonpath='{.items[0].metadata.name}')
        echo "Using MySQL pod: $MYSQL_POD"
        
        # Check if database already exists (skip if it does)
        if kubectl exec -n zabbix $MYSQL_POD -- mysql -u zabbix -pzabbix123! -e "USE zabbix; SELECT 1;" 2>/dev/null; then
          echo "ðŸ“‹ Zabbix database already exists and accessible - skipping initialization"
        else
          echo "ðŸ“‹ Initializing new Zabbix database..."
          
          # Create database and user
          kubectl exec -n zabbix $MYSQL_POD -- mysql -u root -pZabbixRoot123! -e "
            CREATE DATABASE IF NOT EXISTS zabbix CHARACTER SET utf8mb4 COLLATE utf8mb4_bin;
            CREATE USER IF NOT EXISTS 'zabbix'@'%' IDENTIFIED BY 'zabbix123!';
            GRANT ALL PRIVILEGES ON zabbix.* TO 'zabbix'@'%';
            FLUSH PRIVILEGES;"
          
          echo "âœ… Database and user created successfully"
        fi

    - name: Deploy Zabbix Server
      run: |
        echo "ðŸš€ Deploying Zabbix Server..."
        kubectl apply -f applications/zabbix/k8s/zabbix-server.yaml
        
        # Wait for Zabbix server to be ready
        kubectl wait --for=condition=ready pod -l app=zabbix-server -n zabbix --timeout=600s
        
        # Verify Zabbix server is running
        kubectl get pods -n zabbix -l app=zabbix-server
        echo "âœ… Zabbix Server deployed successfully"

    - name: Deploy Zabbix Web Frontend
      run: |
        echo "ðŸŒ Deploying Zabbix Web Frontend..."
        kubectl apply -f applications/zabbix/k8s/zabbix-web.yaml
        
        # Wait for web frontend to be ready
        kubectl wait --for=condition=ready pod -l app=zabbix-web -n zabbix --timeout=300s
        
        # Verify web frontend is running
        kubectl get pods -n zabbix -l app=zabbix-web
        echo "âœ… Zabbix Web Frontend deployed successfully"

    - name: Deploy Zabbix Additional Components
      run: |
        echo "ðŸ“Š Deploying Zabbix additional components (Java Gateway, Proxy)..."
        kubectl apply -f applications/zabbix/k8s/zabbix-additional.yaml
        
        # Wait for additional components to be ready
        kubectl wait --for=condition=ready pod -l app=zabbix-java-gateway -n zabbix --timeout=180s || echo "âš ï¸ Java Gateway may still be starting"
        kubectl wait --for=condition=ready pod -l app=zabbix-proxy -n zabbix --timeout=180s || echo "âš ï¸ Proxy may still be starting"
        
        # Verify additional components are running
        kubectl get pods -n zabbix -l app=zabbix-java-gateway
        kubectl get pods -n zabbix -l app=zabbix-proxy
        echo "âœ… Zabbix additional components deployed successfully"

    - name: Deploy Zabbix Ingress
      run: |
        echo "ðŸ”— Creating Zabbix LoadBalancer service (bypassing ingress validation issues)..."
        
        # Apply LoadBalancer service (bypasses NGINX ingress certificate validation)
        kubectl apply -f applications/zabbix/k8s/zabbix-loadbalancer-only.yaml
        
        # Show LoadBalancer information instead of ingress
        kubectl get svc -n zabbix
        echo "âœ… LoadBalancer service created successfully"

    - name: Verify Zabbix Deployment
      run: |
        echo "ðŸ” Verifying complete Zabbix deployment..."
        
        # Check all pods are running
        kubectl get pods -n zabbix -o wide
        
        # Check services
        kubectl get services -n zabbix
        
        # Check LoadBalancer services  
        echo "ðŸ” LoadBalancer Services:"
        kubectl get svc -n zabbix -o wide
        
        # Get Application Gateway IP for access
        APPGW_IP=$(az network public-ip show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name pip-appgw-devops-eastus --query ipAddress -o tsv)
        echo "ðŸŒ Zabbix will be accessible at: http://$APPGW_IP/zabbix"
        echo "ðŸ“ Default credentials: Admin / zabbix"
        
        # Final verification - check if all expected pods are running
        EXPECTED_PODS=3  # MySQL, Server, Web
        RUNNING_PODS=$(kubectl get pods -n zabbix --field-selector=status.phase=Running --no-headers | wc -l)
        
        if [ "$RUNNING_PODS" -ge "$EXPECTED_PODS" ]; then
          echo "âœ… All Zabbix components are running successfully!"
          echo "DEPLOYMENT_SUCCESS=true" >> $GITHUB_OUTPUT
        else
          echo "âš ï¸ Some Zabbix components may not be fully ready yet"
          echo "   Running pods: $RUNNING_PODS / Expected: $EXPECTED_PODS"
          kubectl describe pods -n zabbix
          echo "DEPLOYMENT_SUCCESS=false" >> $GITHUB_OUTPUT
        fi

  # Deploy Application Only (Skip Infrastructure)
  deploy-zabbix-only:
    runs-on: ubuntu-latest
    environment: production
    if: ${{ github.event.inputs.deployment_type == 'application-only' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure CLI Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Install and Setup kubectl and Helm
      run: |
        echo "ðŸ”§ Setting up kubectl and Helm..."
        
        # Install kubectl if not available
        if ! command -v kubectl &> /dev/null; then
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
        fi
        
        # Install Helm if not available
        if ! command -v helm &> /dev/null; then
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
        fi
        
        echo "âœ… kubectl and Helm are ready"

    - name: Get AKS credentials
      run: |
        echo "ðŸ”‘ Getting AKS credentials for application-only deployment..."
        echo "Cluster: ${{ env.AKS_CLUSTER_NAME }}"
        echo "Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
        
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER_NAME }} \
          --overwrite-existing
        
        # Verify connection
        kubectl cluster-info
        kubectl get nodes
        echo "âœ… AKS connection verified"

    - name: Deploy Zabbix Application (Application-Only Mode)
      run: |
        echo "ðŸš€ Deploying Zabbix application components..."
        
        # Create namespace
        kubectl create namespace zabbix --dry-run=client -o yaml | kubectl apply -f -
        
        # Apply all Zabbix resources
        kubectl apply -f applications/zabbix/k8s/zabbix-config.yaml
        kubectl apply -f applications/zabbix/k8s/zabbix-mysql.yaml
        kubectl apply -f applications/zabbix/k8s/zabbix-server.yaml  
        kubectl apply -f applications/zabbix/k8s/zabbix-web.yaml
        kubectl apply -f applications/zabbix/k8s/zabbix-additional.yaml
        kubectl apply -f applications/zabbix/k8s/zabbix-loadbalancer-only.yaml
        
        # Wait for all pods to be ready
        echo "â³ Waiting for all Zabbix components to be ready..."
        kubectl wait --for=condition=ready pod -l app=zabbix-mysql -n zabbix --timeout=600s
        kubectl wait --for=condition=ready pod -l app=zabbix-server -n zabbix --timeout=600s  
        kubectl wait --for=condition=ready pod -l app=zabbix-web -n zabbix --timeout=300s
        
        # Verify deployment
        kubectl get pods -n zabbix -o wide
        kubectl get services -n zabbix
        echo "ðŸ” LoadBalancer Services (instead of ingress):"
        kubectl get svc -n zabbix -o wide
        
        echo "âœ… Zabbix application deployed successfully in application-only mode!"

  # Final Status Report
  report-status:
    needs: [deploy-infrastructure, deploy-zabbix, deploy-zabbix-only]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Generate Deployment Report
      run: |
        echo "# ðŸŽ¯ **Zabbix AKS Deployment Report**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Run Details:**" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸƒ **Run Number**: ${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ‘¤ **Triggered By**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "- âš¡ **Event**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸŽ¯ **Deployment Type**: ${{ env.DEPLOYMENT_TYPE }}" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ› ï¸  **Infrastructure Method**: ${{ env.INFRASTRUCTURE_METHOD }}" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ“Š **Terraform Mode**: ${{ env.TERRAFORM_MODE }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "**Job Results:**" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ—ï¸  **Infrastructure**: ${{ needs.deploy-infrastructure.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ“± **Application (Full)**: ${{ needs.deploy-zabbix.result }}" >> $GITHUB_STEP_SUMMARY  
        echo "- ðŸ“± **Application (Only)**: ${{ needs.deploy-zabbix-only.result }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Determine overall success
        if [[ "${{ needs.deploy-zabbix.result }}" == "success" || "${{ needs.deploy-zabbix-only.result }}" == "success" ]]; then
          echo "**âœ… Overall Status: SUCCESS**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Configure DNS for dal2-devmon-mgt.forescout.com" >> $GITHUB_STEP_SUMMARY
          echo "2. Upload SSL certificate" >> $GITHUB_STEP_SUMMARY
          echo "3. Change default Zabbix admin password (Admin/zabbix)" >> $GITHUB_STEP_SUMMARY
          echo "4. Configure monitoring templates" >> $GITHUB_STEP_SUMMARY
        elif [[ "${{ needs.deploy-infrastructure.result }}" == "success" && "${{ env.DEPLOYMENT_TYPE }}" == "infrastructure-only" ]]; then
          echo "**âœ… Infrastructure Deployment: SUCCESS**" >> $GITHUB_STEP_SUMMARY
          echo "Infrastructure is ready for application deployment." >> $GITHUB_STEP_SUMMARY
        else
          echo "**âŒ Overall Status: FAILED**" >> $GITHUB_STEP_SUMMARY
          echo "Check individual job logs for details." >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Redeployment Options:**" >> $GITHUB_STEP_SUMMARY
        echo "- **Full Redeploy**: Use 'redeploy-clean' deployment type" >> $GITHUB_STEP_SUMMARY
        echo "- **App Only**: Use 'application-only' to redeploy just Zabbix" >> $GITHUB_STEP_SUMMARY
        echo "- **Infrastructure Only**: Use 'infrastructure-only' for infra changes" >> $GITHUB_STEP_SUMMARY
        echo "- **Reset Database**: Enable 'reset_database' option (âš ï¸ destroys data)" >> $GITHUB_STEP_SUMMARY
